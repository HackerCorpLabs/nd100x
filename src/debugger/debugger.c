#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>

#define WITH_DEBUGGER



#include "debugger.h"
#include "../cpu/cpu_types.h"
#include "../cpu/cpu_protos.h"

#ifdef WITH_DEBUGGER

#include "../../external/libdap/libdap/include/dap_server.h"
#include "../../external/libdap/libdap/include/dap_server_cmds.h"
#include "../../external/libsymbols/include/symbols.h"
#include "symbols_support.h"
#include "machine_types.h"
#include "machine_protos.h"

#include "ndlib_types.h"
#include "ndlib_protos.h"

// Forward declarations for CPU breakpoint functions
extern void breakpoint_manager_add(uint16_t address, BreakpointType type, const char *condition, const char *hitCondition, const char *logMessage);
extern void breakpoint_manager_remove(BreakpointManager *mgr, uint16_t address, int type);
extern int breakpoint_manager_check(uint16_t address, BreakpointEntry** matches[], int* matchCount);

// Define scope IDs
#define SCOPE_ID_LOCALS 1000
#define SCOPE_ID_REGISTERS 1001
#define SCOPE_ID_INTERNAL_REGISTERS 1002

#define SCOPE_ID_STATUS_FLAGS 1100
#define SCOPE_ID_MEM_PT 1101
#define SCOPE_ID_MEM_APT 1102


// DAP server instance
DAPServer* server;    

// Global symbol table
static symbol_table_t* g_symbol_table = NULL;


#ifdef _WIN32
    #include <windows.h>
    HANDLE p_debugger_thread;    
#else
    // Two defines for Linux, to make the compiler not complain about the WIN32 API (which is autogenerated in the proto file)

    #include <stdatomic.h>
	#include <pthread.h>
    pthread_t p_debugger_thread;
#endif


#include "debugger_protos.h"
#include "debugger.h"



#ifdef _WIN32
debugger_thread_win(LPVOID lpParam)
#else
void *debugger_thread(void *arg)
#endif
{


    int port = 4711;
    int ret = ndx_server_init(port);    
    if (ret != 0) {
        printf("Failed to initialize DAP server\n");
        THREAD_RETURN(0);              
    }


    printf("NDX debugger listening on port %d...\n", port);
    printf("Press Ctrl+C to exit\n");
    
    // Run the server's message processing loop
    if (dap_server_run(server) != 0) {
        fprintf(stderr, "Error: Server message loop failed.\n");
        ndx_server_stop();    
        THREAD_RETURN(0);    
    }

#if _old_
    while (true) {
        printf("Debugger thread running\n");
        sleep(10);  // Let the CPU run a bit

        set_debugger_requested_control(true);           
    
        // Wait for the CPU to pause
        while (get_cpu_run_mode() != CPU_PAUSED) {
            usleep(100000);  // 100 ms wait before checking again
        }    

        printf("Debugger: CPU is paused. Reading state...\n");


        printf("CPU STATE 1:\n");
        printf("  PC  = %06o\n", gPC);
        printf("  A = %06o\n", gA);
        printf("  X = %06o\n", gX);  


        printf(">>>>>>>>>>--------------------------------\n");
        printf("Debugger: Stepping CPU\n");  
        // Stepping 10
        cpu_run(1000);
        printf("------------------>>>>>>>>>>-------------\n");

        printf("  PC  = %06o\n", gPC);
        printf("  A = %06o\n", gA);
        printf("  X = %06o\n", gX);  

        



        printf("Debugger: resuming CPU\n");        
        printf("============================================\n");

        // Release control of the CPU, let the CPU run normal again
        debuggerReleaseControl();                    
    }

#endif // _old_

    THREAD_RETURN(0);
}


void start_debugger() {
    		// Start the debugger thread
    #ifdef _WIN32
        p_debugger_thread = CreateThread(
            NULL,                // default security attributes
            0,                   // default stack size
            debugger_thread_win, // thread function
            NULL,                // argument to thread function
            0,                   // default creation flags
            NULL);               // receive thread identifier (optional)
    #else
        pthread_create(&p_debugger_thread, NULL, debugger_thread, NULL);
    #endif
}


void stop_debugger() {
    
	// Clean up the debugger thread
    if (p_debugger_thread) {
        // Signal the thread to terminate
        // (You might need to add a flag to signal the thread to exit)


        #ifdef _WIN32
            TerminateThread(p_debugger_thread, 0);
        #else
            pthread_kill(p_debugger_thread, SIGINT);
        #endif

        // Wait for the thread to finish
        pthread_join(p_debugger_thread, NULL);
    }
}


const char* cpuStopReasonToString(CpuStopReason r) {
    switch (r) {
        case STOP_REASON_STEP: return "step";
        case STOP_REASON_BREAKPOINT: return "breakpoint";
        case STOP_REASON_EXCEPTION: return "exception";
        case STOP_REASON_PAUSE: return "pause";
        case STOP_REASON_ENTRY: return "entry";
        case STOP_REASON_GOTO: return "goto";
        case STOP_REASON_FUNCTION_BREAKPOINT: return "function breakpoint";
        case STOP_REASON_DATA_BREAKPOINT: return "data breakpoint";
        case STOP_REASON_INSTRUCTION_BREAKPOINT: return "instruction breakpoint";
        default: return "pause";
    }
}


static int cmd_wait_for_debugger (DAPServer *server) 
{
    printf("DAP adapter has requested CPU pause\n");

    // Tell CPU thread we want it to pause
    if (get_cpu_run_mode() == CPU_SHUTDOWN) return -1; // CPU is shutting down, no need to pause

    set_debugger_request_pause(true);

    // Now wait until CPU acknowledges and grants control
    while(!get_debugger_control_granted()) {
        usleep(1000);  // small sleep to avoid busy spin
    }

    // CPU is paused; debugger now owns control
    return 0;
}

static int cmd_release_debugger (DAPServer *server) 
{
    printf("DAP adapter has requested CPU resume\n");

    // Release debugger's request to pause (let CPU decide to run/step)    
    set_debugger_request_pause(false);

    // Notify CPU thread that debugger control is released
    set_debugger_control_granted(false);    
    
    return 0;
}
   
static int cmd_check_cpu_events(DAPServer *server) {
    
    CpuStopReason reason = get_cpu_stop_reason();
    if (reason != STOP_REASON_NONE)
    {
        const char* dap_reason_str = cpuStopReasonToString(reason);
        if (dap_server_send_stopped_event(server, dap_reason_str, NULL)==0)
        {                
            // Mesaage sent succesfully, now clear the stop reason
            set_cpu_stop_reason(STOP_REASON_NONE);        
            dap_server_send_output_category(server, DAP_OUTPUT_STDOUT, dap_reason_str);
        }
    }
    
    return 0;
}

int step_cpu(DAPServer *server,  const char* step_type) {
    if (!server) {
        return -1;
    }
    
    uint16_t current_pc = gPC;
    uint16_t target_pc = 0;
    bool stepping_to_line = false;
    
    
  // Access the step command context
    StepCommandContext *ctx = &server->current_command.context.step;

        // Log the stepping action
    char log_message[256];
    snprintf(log_message, sizeof(log_message), 
             "Handling %s command for thread %d", step_type, ctx->thread_id);    
    dap_server_send_output(server, log_message);
    

    // If we have symbol table and want to step by line
    if (g_symbol_table && (ctx->granularity == DAP_STEP_GRANULARITY_LINE || ctx->granularity == DAP_STEP_GRANULARITY_STATEMENT)) {
        // Get the next line's address
        target_pc = symbols_get_next_line_address(g_symbol_table, current_pc);
        
        if (target_pc != 0 && target_pc != current_pc) {
            stepping_to_line = true;
            snprintf(log_message, sizeof(log_message), 
            "Stepping to next line at address %06o\n", target_pc);
            dap_server_send_output(server, log_message);
        } else {
            snprintf(log_message, sizeof(log_message), 
            "No line information found, falling back to instruction stepping\n");
            dap_server_send_output(server, log_message);
        }
    }
    else
    { 
         dap_server_send_output_category(server, DAP_OUTPUT_STDERR, "NO SYMBOLS");
    }
    

    // Set a temporary breakpoint at the target address if we're stepping to a line
    if (stepping_to_line && target_pc != 0 && target_pc != current_pc) {
        char msg[256];
        snprintf(msg, sizeof(msg), "Setting temporary breakpoint at address %06o\n", target_pc);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, msg);
        
        // Use the CPU's breakpoint system to set a temporary breakpoint
        // This breakpoint will be automatically removed when hit
        breakpoint_manager_add(target_pc, BP_TYPE_TEMPORARY, NULL, NULL, NULL);
        
        CPURunMode run_mode = get_cpu_run_mode();
        if (run_mode == CPU_PAUSED)
        {
            // CPU is paused, so we need to resume it
            set_cpu_run_mode(CPU_RUNNING);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, "Switched CPU to running mode\n");
        }        
    }
    return 0;
}




/********************************** CALLBACKS **********************************/


/**
 * @brief Common handler for step operations
 * 
 * This function handles the common logic for all step commands (next, step in, step out).
 * It reads the granularity from the command context and performs the appropriate stepping.
 * 
 * @param server The DAP server instance
 * @param step_type A string describing the step type for logging ("next", "step in", "step out")
 * @return int 0 on success, non-zero on failure
 */
static int handle_step_command(DAPServer *server, const char* step_type) {
    if (!server) {
        return -1;
    }
    // Access the step command context
    StepCommandContext *ctx = &server->current_command.context.step;
    
    // Log the stepping action
    char log_message[256];
    snprintf(log_message, sizeof(log_message), 
             "Handling %s command for thread %d", step_type, ctx->thread_id);    
    dap_server_send_output(server, log_message);
    
    // Handle different granularity types
    switch (ctx->granularity) {
        case DAP_STEP_GRANULARITY_INSTRUCTION:
            snprintf(log_message, sizeof(log_message), 
                     "Stepping by instruction (%s)\n", step_type);
            dap_server_send_output(server, log_message);
            
            // Increment PC by one instruction for instruction stepping
            server->debugger_state.program_counter += 1;
            break;
            
        case DAP_STEP_GRANULARITY_LINE:
            snprintf(log_message, sizeof(log_message), 
                     "Stepping by line (%s)\n", step_type);
            dap_server_send_output(server, log_message);
            
            // For line stepping, increment PC and line
            server->debugger_state.program_counter += 4;
            server->debugger_state.source_line += 1;
            break;
            
        case DAP_STEP_GRANULARITY_STATEMENT:
        default:
            snprintf(log_message, sizeof(log_message), 
                     "Stepping by statement (%s)\n", step_type);
            dap_server_send_output(server, log_message);
            
            // For statement stepping, increment PC and line (same as line in our mock)
            server->debugger_state.program_counter += 4;
            server->debugger_state.source_line += 1;
            break;
    }
    
    // Let the CPU run until it hits a breakpoint or we have reached the target



    
    return 0;
}

/**
 * @brief Step Next command handler
 * 
 * Handles the 'next' command by stepping over the current line/statement
 * 
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_next(DAPServer *server) {
    return step_cpu(server, "next");
}

/**
 * @brief Step In command handler
 * 
 * Handles the 'stepIn' command by stepping into a function call
 * 
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_step_in(DAPServer *server) {
    return step_cpu(server, "step in");
}

/**
 * @brief Step Out command handler
 * 
 * Handles the 'stepOut' command by stepping out of the current function
 * 
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_step_out(DAPServer *server) {
    return step_cpu(server, "step out");
}

/**
 * @brief Handle DAP scopes request
 *
 * This function creates scope objects for the variables visible in the current stack frame.
 * It defines several scopes:
 * 1. Locals - Local variables
 * 2. CPU Registers - CPU register values
 * 3. Memory - Memory regions
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_scopes(DAPServer *server) {
    if (!server) {
        return -1;
    }
    
    // Extract frame_id from the command context
    int frame_id = server->current_command.context.scopes.frame_id;
    
    printf("Scopes request for frame ID: %d\n", frame_id);
    
    // Define the number of scopes we'll provide
    const int NUM_SCOPES = 4; // Locals, Registers, Internal Registers, Memory
    
    // Allocate memory for the scopes
    DAPScope* scopes = (DAPScope*)calloc(NUM_SCOPES, sizeof(DAPScope));
    if (!scopes) {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR, 
                                      "Error: Failed to allocate memory for scopes\n");
        return -1;
    }
    
    // Set up Locals scope
    int scope_index = 0;
    scopes[scope_index].name = strdup("Locals");
    scopes[scope_index].variables_reference = SCOPE_ID_LOCALS;
    scopes[scope_index].named_variables = 5; // Number of local variables
    scopes[scope_index].indexed_variables = 0;
    scopes[scope_index].expensive = false;
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;
    
    // Set up CPU Registers scope
    scope_index++;
    scopes[scope_index].name = strdup("CPU Registers");
    scopes[scope_index].variables_reference = SCOPE_ID_REGISTERS;
    scopes[scope_index].named_variables = 8; // STS, D, P, B, L, A, T, X
    scopes[scope_index].indexed_variables = 0;
    scopes[scope_index].expensive = false;
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;
    

    // Set up Internal Registers scope
    scope_index++;
    scopes[scope_index].name = strdup("Internal Registers");
    scopes[scope_index].variables_reference = SCOPE_ID_INTERNAL_REGISTERS;
    scopes[scope_index].named_variables = 20; // 20 internal registers
    scopes[scope_index].indexed_variables = 0;
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;
    

    // Set up Memory scope
    scope_index++;
    scopes[scope_index].name = strdup("Memory");
    scopes[scope_index].variables_reference = SCOPE_ID_MEM_PT;
    scopes[scope_index].named_variables = 3; // Number of memory regions
    scopes[scope_index].indexed_variables = 0; 
    scopes[scope_index].expensive = true; // Memory access is expensive
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;
    
    // Store the scopes in the command context for the DAP server to use
    server->current_command.context.scopes.scopes = scopes;
    server->current_command.context.scopes.scope_count = NUM_SCOPES;
           
    return 0;
}

/**
 * @brief Helper function to add a variable to the server's variable array
 * 
 * @param server The DAP server instance
 * @param name Variable name
 * @param value Variable value
 * @param type Variable type
 * @param variables_reference Reference for child variables (0 for leaf variables)
 * @param memory_reference Optional memory reference
 * @param kind Variable kind (property, method, etc.)
 * @param attributes Array of attribute flags
 * @param num_attributes Number of attributes
 * @return DAPVariable* Pointer to the newly added variable or NULL on failure
 */
static DAPVariable* add_variable_to_array(
    DAPServer *server,
    const char* name,
    const char* value,
    const char* type,
    int variables_reference,
    uint32_t memory_reference,
    const char* kind,
    const char** attributes,
    int num_attributes
) {
    if (!server || !name || !value) {
        return NULL;
    }
    
    // Increase the count and reallocate the array
    server->current_command.context.variables.count++;
    server->current_command.context.variables.variable_array = realloc(
        server->current_command.context.variables.variable_array, 
        server->current_command.context.variables.count * sizeof(DAPVariable)
    );
    
    if (!server->current_command.context.variables.variable_array) {
        server->current_command.context.variables.count--;
        return NULL;
    }
    
    // Get a pointer to the newly added variable
    DAPVariable* var = &server->current_command.context.variables.variable_array[
        server->current_command.context.variables.count - 1
    ];
    
    // Initialize the variable with the provided values
    if (name)
        var->name = strdup(name);
    else
        var->name = NULL;
        
    if (value)
        var->value = strdup(value);
    else
        var->value = NULL;
        
    if (type)
        var->type = strdup(type);
    else
        var->type = NULL;
        
    var->variables_reference = variables_reference;
    var->named_variables = 0;
    var->indexed_variables = 0;
    var->evaluate_name = NULL;
    
    // Set memory reference
    var->memory_reference = memory_reference;
    
    // Handle presentation hint (default initialization)
    var->presentation_hint.has_kind = false;
    var->presentation_hint.has_visibility = false;
    var->presentation_hint.attributes = DAP_VARIABLE_ATTR_NONE;
    
    // Set kind if provided
    if (kind && kind[0] != '\0') {
        var->presentation_hint.has_kind = true;
        
        // Map string kind to enum
        if (strcmp(kind, "property") == 0) {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_PROPERTY;
        } else if (strcmp(kind, "method") == 0) {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_METHOD;
        } else if (strcmp(kind, "class") == 0) {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_CLASS;
        } else if (strcmp(kind, "data") == 0) {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_DATA;
        } else if (strcmp(kind, "event") == 0) {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_EVENT;
        } else if (strcmp(kind, "baseClass") == 0) {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_BASE_CLASS;
        } else if (strcmp(kind, "innerClass") == 0) {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_INNER_CLASS;
        } else if (strcmp(kind, "interface") == 0) {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_INTERFACE;
        } else if (strcmp(kind, "mostDerived") == 0) {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_MOST_DERIVED;
        } else if (strcmp(kind, "virtual") == 0) {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_VIRTUAL;
        } else if (strcmp(kind, "dataBreakpoint") == 0) {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_DATABREAKPOINT;
        } else {
            // Unknown kind
            var->presentation_hint.has_kind = false;
        }
    }
    
    // Set attributes if provided
    if (attributes && num_attributes > 0) {
        for (int i = 0; i < num_attributes; i++) {
            if (!attributes[i]) continue;
            
            if (strcmp(attributes[i], "static") == 0) {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_STATIC;
            } else if (strcmp(attributes[i], "constant") == 0) {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_CONSTANT;
            } else if (strcmp(attributes[i], "readOnly") == 0) {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_READONLY;
            } else if (strcmp(attributes[i], "rawString") == 0) {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_RAWSTRING;
            } else if (strcmp(attributes[i], "hasObjectId") == 0) {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_HASOBJECTID;
            } else if (strcmp(attributes[i], "canHaveObjectId") == 0) {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_CANHAVEOBJECTID;
            } else if (strcmp(attributes[i], "hasSideEffects") == 0) {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_HASSIDEEFFECTS;
            } else if (strcmp(attributes[i], "hasDataBreakpoint") == 0) {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_HASDATABREAKPOINT;
            } else if (strcmp(attributes[i], "hasChildren") == 0) {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_HASCHILDREN;
            }
        }
    }
    
    return var;
}

/**
 * @brief Add local variables to the variables array
 * 
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer 
 */
static void add_local_variables(DAPServer *server, char* info_message, size_t info_message_size) {
    snprintf(info_message, info_message_size, 
             "Loading local variables for current context\n");
    
    // No local variables in this example, but in a real implementation
    // this would add variables from the current stack frame
    
    // Property kind for all variables
    const char* property_kind = "property";
    const char* no_attributes[] = {NULL};
    
    // Example dummy variable
    add_variable_to_array(
        server,
        "dummy",       // name
        "0",           // value
        "integer",     // type
        0,             // variablesReference
        0,             // memoryReference (no memory reference for locals)
        property_kind, // kind
        no_attributes, // attributes
        0              // num_attributes
    );
}

/**
 * @brief Add CPU register variables to the variables array
 * 
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_register_variables(DAPServer *server, char* info_message, size_t info_message_size) {
    snprintf(info_message, info_message_size, 
             "Loading CPU registers\n");
    
    // Property kind with readonly attribute
    const char* property_kind = "property";
    const char* readonly_attrs[] = {"readOnly"};
    
    // Register formatting
    char value_str[32];
    

    // Add the ST register (Status register)
    snprintf(value_str, sizeof(value_str), "%06o", gSTSr);
    add_variable_to_array(
        server,
        "STS",             // name
        value_str,         // value
        "bitmap",         // type
        SCOPE_ID_STATUS_FLAGS,   // variablesReference
        (uintptr_t)&gA & 0xFFFFFFFF,     // memoryReference - safely truncate to 32-bit if needed
        property_kind,     // kind
        readonly_attrs,    // attributes
        1                  // num_attributes
    );
    

    // Add the D register (Data register)
    snprintf(value_str, sizeof(value_str), "%06o", gD);
    add_variable_to_array(
        server,
        "D",               // name
        value_str,         // value
        "integer",         // type
        0,                 // variablesReference
        (uintptr_t)&gA & 0xFFFFFFFF,     // memoryReference - safely truncate to 32-bit if needed
        property_kind,     // kind
        readonly_attrs,    // attributes
        1                  // num_attributes
    );
    
    // Add the P register (Program Counter)
    snprintf(value_str, sizeof(value_str), "%06o", gPC);
    add_variable_to_array(
        server,
        "P",               // name
        value_str,         // value
        "integer",         // type
        0,                 // variablesReference
        (uintptr_t)&gPC & 0xFFFFFFFF,    // memoryReference - safely truncate to 32-bit if needed
        property_kind,     // kind
        readonly_attrs,    // attributes
        1                  // num_attributes
    );

    // Add the B register (B register)
    snprintf(value_str, sizeof(value_str), "%06o", gB);
    add_variable_to_array(
        server,
        "B",               // name
        value_str,         // value
        "integer",         // type
        0,                 // variablesReference
        (uintptr_t)&gB & 0xFFFFFFFF,     // memoryReference - safely truncate to 32-bit if needed
        property_kind,     // kind
        readonly_attrs,    // attributes
        1                  // num_attributes
    );

    // Add the L register (Link register)
    snprintf(value_str, sizeof(value_str), "%06o", gL);
    add_variable_to_array(
        server,
        "L",               // name
        value_str,         // value
        "integer",         // type
        0,                 // variablesReference
        (uintptr_t)&gL & 0xFFFFFFFF,     // memoryReference - safely truncate to 32-bit if needed
        property_kind,     // kind
        readonly_attrs,    // attributes
        1                  // num_attributes
    );

    // Add the A register (Accumulator)
    snprintf(value_str, sizeof(value_str), "%06o", gA);
    add_variable_to_array(
        server,
        "A",               // name
        value_str,         // value
        "integer",         // type
        0,                 // variablesReference
        (uintptr_t)&gA & 0xFFFFFFFF,     // memoryReference - safely truncate to 32-bit if needed
        property_kind,     // kind
        readonly_attrs,    // attributes
        1                  // num_attributes
    );
    
    // Add the T register (T register)
    snprintf(value_str, sizeof(value_str), "%06o", gT);
    add_variable_to_array(
        server,
        "T",               // name
        value_str,         // value
        "integer",         // type
        0,                 // variablesReference
        (uintptr_t)&gT & 0xFFFFFFFF,     // memoryReference - safely truncate to 32-bit if needed
        property_kind,     // kind
        readonly_attrs,    // attributes
        1                  // num_attributes
    );

    // Add the X register (Index register)
    snprintf(value_str, sizeof(value_str), "%06o", gX);
    add_variable_to_array(
        server,
        "X",               // name
        value_str,         // value
        "integer",         // type
        0,                 // variablesReference
        (uintptr_t)&gX & 0xFFFFFFFF,     // memoryReference - safely truncate to 32-bit if needed
        property_kind,     // kind
        readonly_attrs,    // attributes
        1                  // num_attributes
    );
}

/**
 * @brief Add internal CPU register variables to the variables array
 * 
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_internal_registers_variables(DAPServer *server, char* info_message, size_t info_message_size) {
    snprintf(info_message, info_message_size, 
             "Loading internal CPU registers\n");
    
    // Property kind with readonly attribute
    const char* property_kind = "property";
    const char* readonly_attrs[] = {"readOnly"};
    
    // Register formatting
    char value_str[32];
    
    // Define the internal registers with their addresses
    struct {
        const char* name;
        uint16_t* reg_ptr;
        const char* type;
    } internal_regs[] = {
        {"PANC", &gReg->reg_PANC, "octal"}, // Panel control
        {"PANS", &gReg->reg_PANS, "octal"}, // Panel status
        {"OPR", &gReg->reg_OPR, "octal"},   // Operator register
        {"LMP", &gReg->reg_LMP, "octal"},   // Panel data display buffer register
        {"PGS", &gReg->reg_PGS, "octal"},   // Paging status register
        {"PVL", &gReg->reg_PVL, "octal"},   // Page violation limit register
        {"IIC", &gReg->reg_IIC, "octal"},   // Internal interrupt code register
        {"IID", &gReg->reg_IID, "octal"},   // Internal interrupt detect register
        {"IIE", &gReg->reg_IIE, "octal"},   // Internal interrupt enable register
        {"PID", &gReg->reg_PID, "octal"},   // Priority interrupt detect register
        {"PIE", &gReg->reg_PIE, "octal"},   // Priority interrupt enable register
        {"CSR", &gReg->reg_CSR, "octal"},   // Control store register
        {"CCL", &gReg->reg_CCL, "octal"},   // Cache clear register
        {"LCIL", &gReg->reg_LCIL, "octal"}, // Lower cache inhibit limit register
        {"ALD", &gReg->reg_ALD, "octal"},   // Auto-load descriptor register
        {"UCIL", &gReg->reg_UCIL, "octal"}, // Upper cache inhibit limit register
        {"PES", &gReg->reg_PES, "octal"},   // Page error status register
        {"PGC", &gReg->reg_PGC, "octal"},   // Page count register
        {"PEA", &gReg->reg_PEA, "octal"},   // Page error address register
        {"ECCR", &gReg->reg_ECCR, "octal"}, // Error correction control register
    };
    
    const int num_regs = sizeof(internal_regs) / sizeof(internal_regs[0]);
    
    // Add each internal register to the variable array
    for (int i = 0; i < num_regs; i++) {
        // Format the register value in octal
        snprintf(value_str, sizeof(value_str), "%06o", *(internal_regs[i].reg_ptr));
        
        // Add the register to the variable array
        add_variable_to_array(
            server,
            internal_regs[i].name,    // name
            value_str,                // value
            internal_regs[i].type,    // type
            0,                        // variablesReference (no children)
            (uintptr_t)(internal_regs[i].reg_ptr) & 0xFFFFFFFF, // memoryReference - safely truncate to 32-bit if needed
            property_kind,            // kind
            readonly_attrs,           // attributes
            1                         // num_attributes
        );
    }
}

/**
 * @brief Add status flags from the STS register to the variables array
 * 
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_status_flag_variables(DAPServer *server, char* info_message, size_t info_message_size) {
    snprintf(info_message, info_message_size, 
             "Loading CPU status flags\n");
    
    // Property kind with readonly attribute
    const char* property_kind = "property";
    const char* readonly_attrs[] = {"readOnly"};
    
    // Status flag definitions with bit positions
    struct {
        const char* name;
        int bit_pos;
        const char* description;
    } status_flags[] = {
        {"PTM", 0, "Program Test Mode"},
        {"TG", 1, "Trap Generate"},
        {"K", 2, "Stack Overflow Flag"},
        {"Z", 3, "Zero Flag"},
        {"Q", 4, "Q Flag"},
        {"O", 5, "Overflow Flag"},
        {"C", 6, "Carry Flag"},
        {"M", 7, "Memory Parity Error Flag"},
        {"PL", 8, "Program Level (bits 8-11)"},
        {"N100", 12, "Nord 100 Indicator"},
        {"SEXI", 13, "Extended MMS Addressing Indicator"},
        {"PONI", 14, "Memory Management On/Off Indicator"},
        {"IONI", 15, "Interrupt System On/Off Indicator"}
    };
    
    const int num_flags = sizeof(status_flags) / sizeof(status_flags[0]);
    
    // Get the current STS register value
    uint16_t sts_value = gSTSr;
    
    // Add each flag to the variable array
    for (int i = 0; i < num_flags; i++) {
        // Get the bit value (special handling for PL which is 4 bits)
        bool value;
        char value_str[32];
        
        if (strcmp(status_flags[i].name, "PL") == 0) {
            // Extract 4-bit PL field
            int pl_value = (sts_value >> 8) & 0x0F;
            snprintf(value_str, sizeof(value_str), "%d", pl_value);
    } else {
            // Extract 1-bit flags
            value = (sts_value >> status_flags[i].bit_pos) & 0x01;
            snprintf(value_str, sizeof(value_str), "%s", value ? "true" : "false");
        }
        
        // Create a display name with description
        char display_name[64];
        snprintf(display_name, sizeof(display_name), "%s (%s)", 
                 status_flags[i].name, status_flags[i].description);
        
        // Add the flag to the variable array
        add_variable_to_array(
            server,
            display_name,          // name with description
            value_str,             // value (true/false or numeric for PL)
            strcmp(status_flags[i].name, "PL") == 0 ? "integer" : "boolean", // type
            0,                     // variablesReference (no children)
            0,                     // memoryReference
            property_kind,         // kind
            readonly_attrs,        // attributes
            1                      // num_attributes
        );
    }
}

/**
 * @brief Add memory regions to the variables array
 * 
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_memory_region_variables(DAPServer *server, char* info_message, size_t info_message_size) {
    snprintf(info_message, info_message_size, 
             "Loading memory regions (Code section, Data section, etc.)\n");
    
    // Property kind with readonly attribute
    const char* property_kind = "property";
    const char* no_attributes[] = {NULL};
    
    // Add memory regions - these are examples and should be adjusted based on
    // the actual memory layout of the ND-100 system
    
    // Code section - an example region where program code resides
    add_variable_to_array(
        server,
        "Memory (Code - PT)",     // name
        "000000-077777",    // value
        "memory",           // type
        1,                  // variablesReference
        SCOPE_ID_MEM_PT,    // memoryReference
        property_kind,      // kind
        no_attributes,      // attributes
        0                   // num_attributes
    );
    
    // Data section - an example region where data resides
    add_variable_to_array(
        server,
        "Memory (DATA - APT)",     // name
        "000000-077777",    // value
        "memory",           // type
        SCOPE_ID_MEM_APT,   // variablesReference
        0000,               // memoryReference
        property_kind,      // kind
        no_attributes,      // attributes
        0                   // num_attributes
    );
}

/**
 * @brief Handle DAP variables request
 * 
 * This function provides variables for the requested container (scope).
 * It creates variables based on CPU state, memory content, etc.
 * 
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_variables(DAPServer *server) {
    if (!server) {
        return -1;
    }

    // Extract variables reference from the command context
    int variables_reference = server->current_command.context.variables.variables_reference;
    
    printf("Variables request for reference: %d\n", variables_reference);
    
    // Buffer for informational messages
    char info_message[256] = {0};

    // Reset variable array count
    server->current_command.context.variables.count = 0;
    server->current_command.context.variables.variable_array = NULL;

    // Handle different variable reference types
    switch (variables_reference) {
        case SCOPE_ID_LOCALS: {
            // Use our helper function for local variables
            add_local_variables(server, info_message, sizeof(info_message));
            break;
        }
        
        case SCOPE_ID_REGISTERS: {
            // Use our helper function for register variables
            add_register_variables(server, info_message, sizeof(info_message));
            break;
        }

        case SCOPE_ID_INTERNAL_REGISTERS: {
            // Use our helper function for internal registers variables
            add_internal_registers_variables(server, info_message, sizeof(info_message));
            break;
        }
         
        case SCOPE_ID_STATUS_FLAGS: {
            // Use our helper function for status flag variables
            add_status_flag_variables(server, info_message, sizeof(info_message));
            break;
        }

        case SCOPE_ID_MEM_PT: { // TODO: Make sure we read through PT
            // Use our helper function for memory region variables
            add_memory_region_variables(server, info_message, sizeof(info_message));
            break;
        }

        case SCOPE_ID_MEM_APT: { // TODO: Force PT to be APT
            // Use our helper function for memory region variables
            add_memory_region_variables(server, info_message, sizeof(info_message));
            break;
        }
            
        default:
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, "Unknown variable reference\n");
            break;
    }
    
    // Output info message if we have one
    if (info_message[0] != '\0') {
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, info_message);
    }

    // The variables will be used by handle_variables and converted to JSON
    // We don't need to clean up here, as the caller (handle_variables) will handle it
    // This is intentional to allow the response to be sent before freeing the memory
           
    return 0;
}

/**
 * @brief Handle DAP stackTrace request
 * 
 * This function creates a stack trace response with the current call stack,
 * including source file locations and line numbers. In this implementation,
 * we create at least one stack frame for the current PC location.
 * 
 * @param server The DAP server instance
 * @return int 0 on success, -1 on failure
 */
static int cmd_stack_trace(DAPServer *server) {

    if (!server)
    {
        return -1;
    }
    
    // Log stack trace request to debugger console
    char log_message[256];
    snprintf(log_message, sizeof(log_message), 
             "StackTrace request for thread %d (start=%d, count=%d)", 
             server->debugger_state.current_thread_id, 
             server->current_command.context.stack_trace.start_frame, 
             server->current_command.context.stack_trace.levels);
    dap_server_send_output(server, log_message);
    

    // Get current PC value
    uint16_t current_pc = gPC;
    
    // Initialize stack frame information
    server->current_command.context.stack_trace.frame_count = 1; // We'll create one frame for now
    server->current_command.context.stack_trace.frames = malloc(sizeof(DAPStackFrame));
    
    if (!server->current_command.context.stack_trace.frames) {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR, 
                                      "Error: Failed to allocate memory for stack frames\n");
        return -1;
    }
    
    // Initialize the frame
    DAPStackFrame* frame = &server->current_command.context.stack_trace.frames[0];
    frame->id = 0; // First frame has ID 0
    frame->name = NULL;
    frame->source_path = NULL;
    frame->source_name = NULL;
    frame->line = 0;
    frame->column = 0;
    frame->end_line = 0;
    frame->end_column = 0;
    frame->can_restart = false;
    frame->instruction_pointer_reference = NULL;
    frame->module_id = NULL;
    frame->presentation_hint = DAP_FRAME_PRESENTATION_NORMAL;
    
    // Try to get symbol information if we have a symbol table
    if (g_symbol_table) {
        // Get source location information
        int line = symbols_get_line(g_symbol_table, current_pc);
        const char* file = symbols_get_file(g_symbol_table, current_pc);
        const symbol_entry_t* symbol = symbols_lookup_by_address(g_symbol_table, current_pc);
        
        if (line > 0 && file) {
            // We found source information
            frame->line = line;
            frame->source_path = strdup(file);
            
            // Extract source name from path
            const char* name = strrchr(file, '/');
            if (name) {
                frame->source_name = strdup(name + 1);
            } else {
                frame->source_name = strdup(file);
            }
            
            // Create a frame name from the symbol or PC
            char frame_name[256];
            if (symbol && symbol->name) {
                snprintf(frame_name, sizeof(frame_name), "%s at %06o", symbol->name, current_pc);
            } else {
                snprintf(frame_name, sizeof(frame_name), "frame at %06o", current_pc);
            }
            frame->name = strdup(frame_name);
            
            // Log the source mapping
            char log_msg[256];
            snprintf(log_msg, sizeof(log_msg), "PC %06o mapped to %s:%d\n", 
                     current_pc, file, line);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_msg);
        } else {
            // No source information found, use PC as frame name
            char frame_name[256];
            snprintf(frame_name, sizeof(frame_name), "frame at %06o", current_pc);
            frame->name = strdup(frame_name);
        }
    } else {
        // No symbol table, just use PC as frame name
        char frame_name[256];
        snprintf(frame_name, sizeof(frame_name), "frame at %06o", current_pc);
        frame->name = strdup(frame_name);
    }
    
    // Set instruction pointer reference
    
    frame->instruction_pointer_reference = current_pc;

    return 0;
}

/**
 * @brief Callback for setting exception breakpoints
 * 
 * @param server The DAP server
 * @return int 0 on success, non-zero on failure
 */
static int on_set_exception_breakpoints(DAPServer *server) {
    if (!server) {
        return -1;
    }
    
    // Access filter data from the server's current command context
    const char** filters = server->current_command.context.exception.filters;
    size_t filter_count = server->current_command.context.exception.filter_count;
    const char** conditions = server->current_command.context.exception.conditions;
    size_t condition_count = server->current_command.context.exception.condition_count;

    // Log the received exception filters
    printf("Received %zu exception filters and %zu conditions\n", filter_count, condition_count);
    
    // TODO: Implement exception breakpoint handling
    return 0;
}



/**
 * @brief Command callback for setting breakpoints
 * 
 * @param server DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_set_breakpoints(DAPServer* server) {
    if (!server) {
        return -1;
    }

    // Extract source file info from breakpoint context
    const char* source_path = server->current_command.context.breakpoint.source_path;
    int breakpoint_count = server->current_command.context.breakpoint.breakpoint_count;
    
    if (!source_path || breakpoint_count <= 0) {
        printf("Missing required breakpoint information\n");
        return -1;
    }
    
    // Get filename from path
    const char* source_name = strrchr(source_path, '/');
    if (source_name) {
        source_name++; // Skip the slash
    } else {
        source_name = source_path; // No slash found, use the whole path
    }
    
    printf("Setting %d breakpoints in %s\n", breakpoint_count, source_path);
    
    // TODO: Implement breakpoint handling
    
    // Send console output about the setup
    char output_msg[256];
    snprintf(output_msg, sizeof(output_msg), "Set %d breakpoints in %s\n", 
             breakpoint_count, source_name);
    dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, output_msg);
    
    return 0;
}

/**
 * @brief Initialize symbol table support for the debugger
 * 
 * This function loads symbols from a specified file, trying all supported formats:
 * 1. Map file format
 * 2. a.out binary format
 * 3. STABS .s file format
 * 
 * @param filename Path to the symbol file
 * @return int 0 on success, non-zero on failure
 */
int init_symbol_support(const char* filename) {
    if (!filename) {
        fprintf(stderr, "Error: No symbol file specified\n");
        return -1;
    }
    
    // Free previous symbol table if it exists
    if (g_symbol_table) {
        symbols_free(g_symbol_table);
        g_symbol_table = NULL;
    }
    
    // Initialize symbol table
    g_symbol_table = symbols_create();
    if (!g_symbol_table) {
        fprintf(stderr, "Error: Failed to create symbol table\n");
        return -1;
    }
    
    // Try loading symbols from the file in different formats
    bool result = false;
    
    // First try map file format
    printf("Attempting to load symbols from map file: %s\n", filename);
    result = symbols_load_map(g_symbol_table, filename);
    if (result) {
        printf("Successfully loaded symbols from map file: %s\n", filename);
        return 0;
    }
    
    // If that fails, try a.out format
    printf("Map file format failed, trying a.out format: %s\n", filename);
    result = symbols_load_aout(g_symbol_table, filename);
    if (result) {
        printf("Successfully loaded symbols from a.out binary: %s\n", filename);
        return 0;
    }
    
    // If that fails too, try STABS format
    printf("a.out format failed, trying STABS format: %s\n", filename);
    result = symbols_load_stabs(g_symbol_table, filename);
    if (result) {
        printf("Successfully loaded symbols from STABS file: %s\n", filename);
        return 0;
    }
    
    // If all loading attempts failed
    fprintf(stderr, "Error: Failed to load symbols from %s in any supported format\n", filename);
    symbols_free(g_symbol_table);
    g_symbol_table = NULL;
    return -1;
}

/**
 * @brief Register symbol information with the DAP server
 * 
 * @param server The DAP server instance
 * @param symbol_file Path to the symbol file
 * @return int 0 on success, non-zero on failure
 */
int register_symbol_file_with_dap(DAPServer *server, const char* symbol_file) {
    if (!server || !symbol_file) {
        return -1;
    }
    
    // Load symbols
    int result = init_symbol_support(symbol_file);
    if (result != 0) {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR, 
                                      "Failed to load symbols from any supported format\n");
        return result;
    }
    
    // Get symbol statistics
    int symbol_count = 0;
    int line_count = 0;
    
    // Send a console output event to notify the client
    char message[256];
    snprintf(message, sizeof(message), "Loaded symbol information from %s\n", symbol_file);
    dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, message);
    
    // Print more detailed info about symbols
    // In a real implementation, you would count symbols and line entries
    snprintf(message, sizeof(message), "Symbol table contains address-to-line mapping information\n");
    dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, message);
    
    return 0;
}

/**
 * @brief Handle the launch request from DAP
 * 
 * This function initializes the debugger environment for the specified program:
 * 1. Sets up necessary debugger state with program and source information
 * 2. Initializes execution context and resets debugger state
 * 3. Loads symbol information if map file is provided
 * 4. Sends appropriate events to the client
 * 
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_launch_callback(DAPServer* server) {
    if (!server) {
        return -1;
    }
    
    printf("Launch command received\n");
    
    // Extract launch parameters from debugger state
    const char* program_path = server->debugger_state.program_path;
    const char* source_path = server->debugger_state.source_path;
    const char* map_path = server->debugger_state.map_path;
    bool stop_at_entry = server->debugger_state.stop_at_entry;
    bool no_debug = server->debugger_state.no_debug;
    
    // Log command line arguments if provided
    char** args = server->debugger_state.args;
    int args_count = server->debugger_state.args_count;
    
    if (!program_path) {
        printf("Error: Missing program path in debugger state\n");
        return -1;
    }
    
    printf("Launching program: %s\n", program_path ? program_path : "(null)");
    printf("Source path: %s\n", source_path ? source_path : "(not specified)");
    printf("Map file: %s\n", map_path ? map_path : "(not specified)");
    printf("Stop at entry: %s\n", stop_at_entry ? "yes" : "no");
    printf("No debug: %s\n", no_debug ? "yes" : "no");
    
    // Log command line arguments if present
    if (args && args_count > 0) {
        char arg_log[1024] = "Command line arguments:";
        size_t log_pos = strlen(arg_log);
        
        for (int i = 0; i < args_count && i < 10; i++) { // Limit to 10 args in log
            if (args[i]) {
                int written = snprintf(arg_log + log_pos, sizeof(arg_log) - log_pos, 
                                     " '%s'", args[i]);
                if (written > 0) {
                    log_pos += written;
                }
            }
        }
        
        if (args_count > 10) {
            snprintf(arg_log + log_pos, sizeof(arg_log) - log_pos, " ... (%d more)", 
                    args_count - 10);
        }
        
        printf("%s\n", arg_log);
    }
    
    // Reset CPU state to appropriate values
    // In a real debugger, this would be where we would initialize the CPU
    // with the program's binary data
    
    // Set debugger state
    server->is_running = true;
    server->attached = true;
    server->debugger_state.has_stopped = true;
    server->debugger_state.current_thread_id = 1; // make sure we have a thread id


    server->debugger_state.source_line = 1;   // Start at line 1
    server->debugger_state.source_column = 1; // Start at column 1
    // Try to load symbols using different approaches
    bool symbols_loaded = false;


    // Load program
    if (program_path) {
        printf("Attempting to load program: %s\n", program_path);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, 
                                      "Loading program...\n");
         
    	program_load(BOOT_AOUT, program_path, true);	
         gPC = STARTADDR;
    }
    
    // If map file is provided, try it first
    if (map_path) {
        printf("Attempting to load symbols from map file: %s\n", map_path);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, 
                                      "Loading symbols from map file...\n");
        
        if (register_symbol_file_with_dap(server, map_path) == 0) {
            symbols_loaded = true;
            
            // Send a detailed message about the symbols
            char message[256];
            snprintf(message, sizeof(message), "Successfully loaded symbols from map file: %s\n", map_path);
            dap_server_send_output_category(server, DAP_OUTPUT_IMPORTANT, message);
        }
    }
    
    // If no symbols yet and we have a program path, try it as a.out
    if (!symbols_loaded && program_path) {
        printf("Attempting to load symbols from program binary: %s\n", program_path);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, 
                                      "Loading symbols from program binary...\n");
        
        if (register_symbol_file_with_dap(server, program_path) == 0) {
            symbols_loaded = true;
            
            // Send a detailed message about the symbols
            char message[256];
            snprintf(message, sizeof(message), "Successfully loaded symbols from binary: %s\n", program_path);
            dap_server_send_output_category(server, DAP_OUTPUT_IMPORTANT, message);
        }
    }
    
    // Check for potential STABS file (look for .s file with same base name as program)
    if (!symbols_loaded && program_path) {
        char stabs_path[600] = {0};
        
        // Get base program name without extension
        const char* program_basename = strrchr(program_path, '/');
        if (program_basename) {
            program_basename++; // Skip the slash
        } else {
            program_basename = program_path;
        }
        
        // Find extension
        const char* extension = strrchr(program_basename, '.');
        if (extension) {
            // Take only the base name
            size_t base_len = extension - program_basename;
            char base_name[256] = {0};
            strncpy(base_name, program_basename, base_len < 255 ? base_len : 255);
            
            // Create potential STABS file path (same directory, .s extension)
            char dir_path[256] = {0};
            if (program_basename > program_path) {
                // Copy directory part
                size_t dir_len = program_basename - program_path - 1; // -1 to exclude the slash
                strncpy(dir_path, program_path, dir_len < 255 ? dir_len : 255);
            }
            
            // Construct full STABS path
            if (dir_path[0]) {
                snprintf(stabs_path, sizeof(stabs_path), "%s/%s.s", dir_path, base_name);
            } else {
                snprintf(stabs_path, sizeof(stabs_path), "%s.s", base_name);
            }
            
            // Try to load STABS file
            printf("Attempting to load symbols from STABS file: %s\n", stabs_path);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, 
                                          "Looking for STABS debug file...\n");
            
            // Check if file exists before trying to load
            FILE* f = fopen(stabs_path, "r");
            if (f) {
                fclose(f);
                
                dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, 
                                              "Found STABS file, loading symbols...\n");
                                              
                if (register_symbol_file_with_dap(server, stabs_path) == 0) {
                    symbols_loaded = true;
                    
                    // Send a detailed message about the symbols
                    char message[1024];
                    snprintf(message, sizeof(message), "Successfully loaded symbols from STABS: %s\n", stabs_path);
                    dap_server_send_output_category(server, DAP_OUTPUT_IMPORTANT, message);
                }
            } else {
                dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, 
                                              "No STABS debug file found\n");
            }
        }
    }
    
    // If no symbols loaded from any source, warn the user
    if (!symbols_loaded) {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR, 
                                      "Warning: No symbols loaded. Source level debugging may not work correctly.\n");
    }
      // Update the server's program counter from the CPU
    server->debugger_state.program_counter = gPC;
    
    // If we have symbols, try to map initial PC to a source line
    if (g_symbol_table) {
        int line = symbols_get_line(g_symbol_table, gPC);
        const char* file = symbols_get_file(g_symbol_table, gPC);
        
        


        if (line > 0 && file) {
            server->debugger_state.source_line = line;    
            // Show initial source mapping
            char message[256];
            snprintf(message, sizeof(message), "Initial PC %06o mapped to %s:%d\n", 
                     gPC, file, line);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, message);
        }
    }
    
    // Send process event to indicate execution started
    dap_server_send_process_event(server, program_path, 1, true, "launch");
    

    // Output a confirmation message to the debug console
    char message[256];
    snprintf(message, sizeof(message), "Launched program: %s\n", program_path);
    dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, message);
            

    // Send stopped event if stopAtEntry is true
    if (stop_at_entry) {
        dap_server_send_stopped_event(server, "entry", "Stopped at program entry");
        printf("Stopped at entry point\n");
        set_cpu_run_mode(CPU_PAUSED);
        set_cpu_stop_reason(STOP_REASON_ENTRY);
    } else {
        // Send thread started event
        dap_server_send_thread_event(server, "started", 1);                
        set_cpu_run_mode(CPU_RUNNING);
    }

    return 0; // Return success to ensure the response is properly set
}

int ndx_server_init(int port) {
     // Initialize DAP server
    DAPServerConfig config = {
        .transport = {
            .type = DAP_TRANSPORT_TCP,
            .config = {
                .tcp = {
                    .host = "localhost",
                    .port = port
                }
            }
        },                        
    };

    server = dap_server_create(&config);
    if (!server) {
        return -1;
    }


    // Hook up callbacks

    
    // Hook up commands for stopping and starting the debugger's access to the CPU
    dap_server_register_command_callback(server, DAP_WAIT_FOR_DEBUGGER, cmd_wait_for_debugger);
    dap_server_register_command_callback(server, DAP_RELEASE_DEBUGGER, cmd_release_debugger);
    dap_server_register_command_callback(server, DAP_CHECK_CPU_EVENTS, cmd_check_cpu_events);

    // Set up stepping callbacks through command callbacks only
    // Register command-specific implementations using the wrapper functions
    dap_server_register_command_callback(server, DAP_CMD_NEXT, cmd_next);
    dap_server_register_command_callback(server, DAP_CMD_STEP_IN, cmd_step_in);
    dap_server_register_command_callback(server, DAP_CMD_STEP_OUT, cmd_step_out);
    
    // Register exception breakpoint callback
    dap_server_register_command_callback(server, DAP_CMD_SET_EXCEPTION_BREAKPOINTS, on_set_exception_breakpoints);
    
    // Register breakpoint callback
    dap_server_register_command_callback(server, DAP_CMD_SET_BREAKPOINTS, cmd_set_breakpoints);
    
    // Register launch callback
    dap_server_register_command_callback(server, DAP_CMD_LAUNCH, cmd_launch_callback);
    
    // Register stack trace callback
    dap_server_register_command_callback(server, DAP_CMD_STACK_TRACE, cmd_stack_trace);

    // Register scopes callback
    dap_server_register_command_callback(server, DAP_CMD_SCOPES, cmd_scopes);

    // Register variables callback
    dap_server_register_command_callback(server, DAP_CMD_VARIABLES, cmd_variables);
    
    // Configure which capabilities are supported
    set_default_dap_capabilities(server);



    int ret = dap_server_start(server);
    if (ret != 0) {
        dap_server_free(server);
        server = NULL;
        return -1;
    }

    return 0;
}

int ndx_server_stop() {
    if (!server) {
        return -1;
    }

    dap_server_stop(server);
    dap_server_free(server);
    server = NULL;
    return 0;
}

void debugger_kbd_input(char c) {
    if (c == '.') {
        int runMode = get_cpu_run_mode();
        
        printf("P=%6o  RunMode=%d\n", gPC, runMode);
    }

    if (c==' ') {
        cpu_run(1);
        printf("%6o\n", gPC);
    }
}

// Add this before the end of the #ifdef WITH_DEBUGGER section
#ifdef WITH_DEBUGGER
/**
 * @brief Find a symbol by address
 * 
 * @param symtab Symbol table to search
 * @param address Memory address to look up
 * @return const char* Symbol name or NULL if not found
 */
const char* find_symbol_by_address(symbol_table_t* symtab, uint16_t address) {
    if (!symtab) {
        return NULL;
    }
    
    const symbol_entry_t* entry = symbols_lookup_by_address(symtab, address);
    if (entry && entry->name) {
        return entry->name;
    }
    
    return NULL;
}

/**
 * @brief Helper function to find a symbol by address using the global symbol table
 * 
 * @param address Memory address to look up
 * @return const char* Symbol name or NULL if not found
 */
const char* get_symbol_for_address(uint16_t address) {
    return find_symbol_by_address(g_symbol_table, address);
}

/**
 * @brief Get source file and line for an address
 * 
 * @param address Memory address to look up
 * @param line Pointer to store the line number
 * @return const char* Source filename or NULL if not found
 */
const char* get_source_location(uint16_t address, int* line) {
    if (!g_symbol_table || !line) {
        return NULL;
    }
    
    *line = symbols_get_line(g_symbol_table, address);
    return symbols_get_file(g_symbol_table, address);
}
#endif // WITH_DEBUGGER

#endif // WITH_DEBUGGER

// Empty implementations when debugger is not enabled
#ifndef WITH_DEBUGGER





void start_debugger() {
    // Do nothing when debugger is not enabled
}

int ndx_server_init(int port) {
    (void)port;
    return -1; // Not implemented
}

int ndx_server_stop() {
    return -1; // Not implemented
}

void debugger_kbd_input(char c) {
    (void)c; // Unused parameter
}

#endif // !WITH_DEBUGGER

/**
 * @brief Set up the default capabilities for the mock server
 * 
 * This function configures which DAP capabilities our mock server
 * actually supports based on our implementation.
 * 
 * @param server The DAP server instance
 * @return int The number of capabilities set
 */
int set_default_dap_capabilities(DAPServer *server) {
    if (!server) {
        return -1;
    }
            
    return dap_server_set_capabilities(server,
        // These capabilities are fully implemented in the mock server
        DAP_CAP_CONFIG_DONE_REQUEST, true,
        DAP_CAP_EVALUATE_FOR_HOVERS, true,
        DAP_CAP_RESTART_REQUEST, true,
        DAP_CAP_TERMINATE_REQUEST, true,
        
        // End of capabilities
        DAP_CAP_COUNT
    );
}
