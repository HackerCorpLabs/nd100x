#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>


#include "debugger.h"
#include "../cpu/cpu_types.h"
#include "../cpu/cpu_protos.h"

#include "../../external/libdap/libdap/include/dap_server.h"

// DAP server instance
DAPServer* server;    


//#define _DEBUGGER_ENABLED_ // Enables debugger thread support

#ifdef _DEBUGGER_ENABLED_

#ifdef _WIN32
    #include <windows.h>
    HANDLE p_debugger_thread;    
#else
    // Two defines for Linux, to make the compiler not complain about the WIN32 API (which is autogenerated in the proto file)

    #include <stdatomic.h>
	#include <pthread.h>
    pthread_t p_debugger_thread;
#endif


#include "debugger_protos.h"
#include "debugger.h"



#ifdef _WIN32
debugger_thread_win(LPVOID lpParam)
#else
void *debugger_thread(void *arg)
#endif
{


    int port = 4711;
    int ret = ndx_server_init(port);    
    if (ret != 0) {
        printf("Failed to initialize DAP server\n");
        THREAD_RETURN(0);              
    }


    printf("NDX debugger listening on port %d...\n", port);
    printf("Press Ctrl+C to exit\n");
    
    // Run the server's message processing loop
    if (dap_server_run(server) != 0) {
        fprintf(stderr, "Error: Server message loop failed.\n");
        ndx_server_stop();    
        THREAD_RETURN(0);    
    }

#if _old_
    while (true) {
        printf("Debugger thread running\n");
        sleep(10);  // Let the CPU run a bit

        set_debugger_requested_control(true);           
    
        // Wait for the CPU to pause
        while (get_cpu_run_mode() != CPU_PAUSED) {
            usleep(100000);  // 100 ms wait before checking again
        }    

        printf("Debugger: CPU is paused. Reading state...\n");


        printf("CPU STATE 1:\n");
        printf("  PC  = %06o\n", gPC);
        printf("  A = %06o\n", gA);
        printf("  X = %06o\n", gX);  


        printf(">>>>>>>>>>--------------------------------\n");
        printf("Debugger: Stepping CPU\n");  
        // Stepping 10
        cpu_run(1000);
        printf("------------------>>>>>>>>>>-------------\n");

        printf("  PC  = %06o\n", gPC);
        printf("  A = %06o\n", gA);
        printf("  X = %06o\n", gX);  

        



        printf("Debugger: resuming CPU\n");        
        printf("============================================\n");

        // Release control of the CPU, let the CPU run normal again
        debuggerReleaseControl();                    
    }

#endif // _old_

    THREAD_RETURN(0);
}


void start_debugger() {
    		// Start the debugger thread
    #ifdef _WIN32
        p_debugger_thread = CreateThread(
            NULL,                // default security attributes
            0,                   // default stack size
            debugger_thread_win, // thread function
            NULL,                // argument to thread function
            0,                   // default creation flags
            NULL);               // receive thread identifier (optional)
    #else
        pthread_create(&p_debugger_thread, NULL, debugger_thread, NULL);
    #endif
}


/* DAP INTEGRATION */
void WaitForDebugger() {
    set_debugger_requested_control(true);          

    while (get_cpu_run_mode() != CPU_PAUSED) {
        usleep(100000);  // 100 ms wait before checking again
    }
}

// Release control of the CPU, let the CPU run normal again
void ReleaseDebugger() {
    debuggerReleaseControl();   
}   
        

// Function to step the CPU one instruction
static int step_cpu(DAPServer *server) {
    (void)server;

    WaitForDebugger();    
    cpu_run(1);
    ushort PC = gPC;
    ReleaseDebugger();
    return PC;
}

// Function to step the CPU to the next source line
static int step_cpu_line(DAPServer *server) {
    (void)server;
    
    //TODO:  Identify how many instructions to run for a line
    WaitForDebugger();    
    cpu_run(1);
    ushort PC = gPC;
    ReleaseDebugger();
    return PC;
}

// Function to step the CPU to the next statement
static int step_cpu_statement(DAPServer *server) {
    (void)server;
    //TODO:  Identify how many instructions to run for a line

    WaitForDebugger();    
    cpu_run(1);
    ushort PC = gPC;
    ReleaseDebugger();
    return PC;
}


int ndx_server_init(int port) {
     // Initialize DAP server
    DAPServerConfig config = {
        .transport = {
            .type = DAP_TRANSPORT_TCP,
            .config = {
                .tcp = {
                    .host = "localhost",
                    .port = port
                }
            }
        },                
        .stop_at_entry = false,        
    };

    server = dap_server_create(&config);
    if (!server) {
        return -1;
    }


    // Hook up callbacks
    server->step_cpu = step_cpu;
    server->step_cpu_line = step_cpu_line;
    server->step_cpu_statement = step_cpu_statement;


    int ret = dap_server_start(server);
    if (ret != 0) {
        dap_server_free(server);
        server = NULL;
        return -1;
    }

    return 0;
}

int ndx_server_stop() {
    if (!server) {
        return -1;
    }

    dap_server_stop(server);
    dap_server_free(server);
    server = NULL;
    return 0;
}

void debugger_kbd_input(char c) {
    if (c == '.') {
        printf(".");
    }
}


#endif // _DEBUGGER_ENABLED_
