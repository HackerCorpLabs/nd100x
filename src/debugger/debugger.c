#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>
#include <stdatomic.h>

#include "debugger.h"
#include "../cpu/cpu_types.h"
#include "../cpu/cpu_protos.h"

#ifdef WITH_DEBUGGER

#include "../../external/libdap/libdap/include/dap_server.h"
#include "../../external/libdap/libdap/include/dap_server_cmds.h"
#include "../../external/libdap/libdap/include/dap_protocol.h"
#include "../../external/libsymbols/include/symbols.h"
#include "symbols_support.h"
#include "machine_types.h"
#include "machine_protos.h"

#include "ndlib_types.h"
#include "ndlib_protos.h"

#include "debugger_protos.h"

// Forward declarations for CPU breakpoint functions

// Define scope IDs
#define SCOPE_ID_LOCALS 1000
#define SCOPE_ID_REGISTERS 1001
#define SCOPE_ID_LEVELS 1002

#define SCOPE_ID_INTERNAL_REGISTERS_READ 1010
#define SCOPE_ID_INTERNAL_REGISTERS_WRITE 1011

#define SCOPE_ID_STATUS_FLAGS 1100

#define SCOPE_ID_MEM_MMS 1200
#define SCOPE_ID_MEM_PT 1201
#define SCOPE_ID_MEM_APT 1202

#define NUM_SCOPES 8 // Locals, Registers, Levels, Internal read, Internal write, status flags, memory PT, memory APT

// DAP server instance
DAPServer *server;

// Global symbol table

SymbolTables symbol_tables;

// Structure to hold the stack trace information
StackTrace stack_trace;

// Source reference mapping for non-disk sources
typedef struct {
    int sourceReference;
    char *filepath;
    char *content;  // Cached content
} SourceReferenceMap;

static SourceReferenceMap *source_refs = NULL;
static int source_ref_count = 0;
static int next_source_ref = 1000;  // Start from 1000

#ifdef _WIN32
#include <windows.h>
HANDLE p_debugger_thread;
#else
// Two defines for Linux, to make the compiler not complain about the WIN32 API (which is autogenerated in the proto file)

#include <stdatomic.h>
#include <pthread.h>
pthread_t p_debugger_thread;
#endif

#include "debugger_protos.h"
#include "debugger.h"

// Add atomic flag for thread termination
static atomic_bool debugger_thread_should_exit = false;

// Signal handler for the debugger thread
static void debugger_signal_handler(int sig)
{
    if (sig == SIGINT)
    {
        atomic_store(&debugger_thread_should_exit, true);
    }
}

#ifdef _WIN32
debugger_thread_win(LPVOID lpParam)
#else
void *debugger_thread(void *arg)
#endif
{
#ifdef _WIN32
    // Hook up sigint handler to terminate the server
    signal(SIGINT, debugger_signal_handler);
#else
    // Set up signal handler for this thread
    struct sigaction sa;
    sa.sa_handler = debugger_signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGINT, &sa, NULL);
#endif

    int port = 4711;
    int ret = ndx_server_init(port);
    if (ret != 0)
    {
        printf("Failed to initialize DAP server\n");
        THREAD_RETURN(0);
    }

    printf("NDX debugger listening on port %d...\n", port);
    printf("Press Ctrl+C to exit\n");

    // Run the server's message processing loop with periodic checks for exit
    while (server->is_running)
    {
        if (atomic_load(&debugger_thread_should_exit))
            break;

        if (dap_server_run(server) != 0)
        {
            fprintf(stderr, "Error: Server message loop failed.\n");
            break;
        }
        // Small sleep to prevent busy waiting
        usleep(10000); // 10ms
    }

    // Make sure CPU exits
    set_cpu_run_mode(CPU_SHUTDOWN);

    // Stop the server and transport
    dap_server_stop(server);

    // Clean up before exiting
    dap_server_free(server);
    server = NULL;
    THREAD_RETURN(0);
}

void start_debugger()
{
    // Start the debugger thread
#ifdef _WIN32
    p_debugger_thread = CreateThread(
        NULL,                // default security attributes
        0,                   // default stack size
        debugger_thread_win, // thread function
        NULL,                // argument to thread function
        0,                   // default creation flags
        NULL);               // receive thread identifier (optional)
#else
    pthread_create(&p_debugger_thread, NULL, debugger_thread, NULL);
#endif
}

/// @brief Terminate the DAP server
/// @param exit_code
void ndx_server_terminate(int sig)
{

    // Sends a terminated event to the client and terminate the DAP server
    dap_server_terminate(server, 0);
}

/// @brief Stop the DAP server thread
void stop_debugger_thread()
{
    // Signal the thread to exit
    atomic_store(&debugger_thread_should_exit, true);

    // Wait for the thread to finish
    if (p_debugger_thread)
    {
#ifdef _WIN32
        WaitForSingleObject(p_debugger_thread, INFINITE);
        CloseHandle(p_debugger_thread);
#else
        pthread_join(p_debugger_thread, NULL);
#endif

        p_debugger_thread = 0;
    }
}

const char *cpuStopReasonToString(CpuStopReason r)
{
    switch (r)
    {
    case STOP_REASON_STEP:
        return "step";
    case STOP_REASON_BREAKPOINT:
        return "breakpoint";
    case STOP_REASON_EXCEPTION:
        return "exception";
    case STOP_REASON_PAUSE:
        return "pause";
    case STOP_REASON_ENTRY:
        return "entry";
    case STOP_REASON_GOTO:
        return "goto";
    case STOP_REASON_FUNCTION_BREAKPOINT:
        return "function breakpoint";
    case STOP_REASON_DATA_BREAKPOINT:
        return "data breakpoint";
    case STOP_REASON_INSTRUCTION_BREAKPOINT:
        return "instruction breakpoint";
    default:
        return "pause";
    }
}

static int cmd_wait_for_debugger(DAPServer *server)
{
    int cnt = 0;
    int max_cnt = 10000; // 10000 * 1ms = 10s
    // Tell CPU thread we want it to pause
    if (get_cpu_run_mode() == CPU_SHUTDOWN)
        return -1; // CPU is shutting down, no need to pause

    set_debugger_request_pause(true);

    // Now wait until CPU acknowledges and grants control
    while (!get_debugger_control_granted())
    {
        usleep(1000); // small sleep to avoid busy spin (1ms)
        cnt++;
        if (cnt > max_cnt)
        {
            return -1;
        }
    }

    // CPU is paused; debugger now owns control
    return 0;
}

static int cmd_release_debugger(DAPServer *server)
{
    // Release debugger's request to pause (let CPU decide to run/step)
    set_debugger_request_pause(false);

    // Notify CPU thread that debugger control is released
    set_debugger_control_granted(false);

    return 0;
}

static int cmd_check_cpu_events(DAPServer *server)
{

    CpuStopReason reason = get_cpu_stop_reason();
    if (reason != STOP_REASON_NONE)
    {
        const char *dap_reason_str = cpuStopReasonToString(reason);
        
        // Get current source location for detailed context
        int line = 0;
        const char *file = NULL;
        
        // Try to get source location from symbol tables
        if (symbol_tables.symbol_table_stabs) {
            line = symbols_get_line(symbol_tables.symbol_table_stabs, gPC);
            file = symbols_get_file(symbol_tables.symbol_table_stabs, gPC);
        }
        if ((!line || !file) && symbol_tables.symbol_table_map) {
            line = symbols_get_line(symbol_tables.symbol_table_map, gPC);
            file = symbols_get_file(symbol_tables.symbol_table_map, gPC);
        }
        if ((!line || !file) && symbol_tables.symbol_table_aout) {
            line = symbols_get_line(symbol_tables.symbol_table_aout, gPC);
            file = symbols_get_file(symbol_tables.symbol_table_aout, gPC);
        }
        
        // Create detailed stop message
        char description[256];
        if (line > 0 && file) {
            snprintf(description, sizeof(description), 
                    "Stopped at %s:%d (PC=%06o)", file, line, gPC);
        } else {
            snprintf(description, sizeof(description), 
                    "Stopped at PC=%06o", gPC);
        }
        
        if (dap_server_send_stopped_event(server, dap_reason_str, description) == 0)
        {
            server->debugger_state.has_stopped = true;
            // Message sent successfully, now clear the stop reason
            set_cpu_stop_reason(STOP_REASON_NONE);
            // Log to console with detailed info
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, description);
        }
    }

    return 0;
}

static void ensure_cpu_running()
{
    CPURunMode run_mode = get_cpu_run_mode();
    if ((run_mode == CPU_PAUSED) || (run_mode == CPU_BREAKPOINT))
    {
        // CPU is paused, so we need to resume it
        set_cpu_run_mode(CPU_RUNNING);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, "Switched CPU to running mode\n");
    }
}

/********************************** INSTRUCTION ANALYSIS ***********************************/

/// @brief Check if instruction is a procedure call (JPL or similar)
/// @param operand The instruction word
/// @return true if instruction is a call, false otherwise
static bool is_procedure_call(uint16_t operand)
{
    // JPL instruction - Jump and Link (procedure call)
    // Format: 0134xxx (octal), where xxx includes addressing mode and displacement
    // JPL saves return address to L register: L = PC
    // This is the primary procedure call instruction in ND-100
    if ((operand & 0xF800) == 0134000) {
        return true;
    }

    // Note: ENTR (0140135) is NOT a call instruction
    // ENTR sets up a stack frame INSIDE a function but doesn't jump/call
    // It just advances PC by 2 after setting up the frame
    // The actual call happens via JPL before ENTR is executed

    return false;
}

/// @brief Check if instruction is a return (EXIT or similar)
/// @param operand The instruction word
/// @return true if instruction is a return, false otherwise
/// @note This only detects EXIT which returns via L register (paired with JPL)
///       For stack frame returns (LEAVE/ELEAV), use is_c_function_epilogue()
static bool is_procedure_return(uint16_t operand)
{
    // EXIT instruction - Return via L register
    // Opcode: 0146142 (octal) - This is "COPY SL DP" which does P = L
    // Used with JPL calling convention: JPL saves to L, EXIT returns via L
    if (operand == 0146142) {
        return true;
    }

    // Note: LEAVE (0140136) and ELEAV (0140137) are NOT included here
    // They return via stack LINK (Memory[B-128]), not via L register
    // Those are detected by is_c_function_epilogue() instead

    return false;
}

/// @brief Get the target address of a JPL instruction
/// @param pc Current program counter
/// @param operand JPL instruction word
/// @return Target address (simplified P-relative calculation)
/// @note This is a simplified version. Full implementation would need CPU register access
///       for all 8 addressing modes. See New_GetEffectiveAddr() in cpu.c for complete logic.
static uint16_t get_jpl_target_address(uint16_t pc, uint16_t operand)
{
    // JPL format: bits 15-11 = opcode (0134x)
    //             bits 10-8  = addressing mode (X, I, B flags)
    //             bits 7-0   = 8-bit signed displacement

    // Extract 8-bit displacement and sign-extend to 16 bits
    int8_t disp = (int8_t)(operand & 0xFF);
    uint16_t displacement = (uint16_t)(int16_t)disp;

    // Extract addressing mode flags
    // Bit 10 (X): Index by X register
    // Bit 9  (I): Indirect addressing
    // Bit 8  (B): Base-relative (vs P-relative)
    uint8_t mode = (operand >> 8) & 0x07;

    // For simple case, assume P-relative addressing (mode 0)
    // Full implementation would need access to gB, gX registers and memory
    // EA = P + displacement (for P-relative mode)
    uint16_t ea = pc + displacement;

    // TODO: Implement full addressing mode support when we have access to:
    //       - gB register (for B-relative modes)
    //       - gX register (for indexed modes)
    //       - Memory access (for indirect modes)
    //       See New_GetEffectiveAddr() in src/cpu/cpu.c for reference
    (void)mode;  // Unused for now

    return ea;
}

/// @brief Detect if current instruction sequence is a C function prologue
/// @param pc Program counter
/// @return true if looks like C function entry
/// @note ND-100 C compiler uses ENTR instruction for structured stack frames
static bool is_c_function_prologue(uint16_t pc)
{
    // Read the instruction at current PC
    uint16_t operand = ReadVirtualMemory(pc, false);

    // ND-100 C calling convention uses ENTR instruction to enter stack frames
    // ENTR opcode: 0140135 (octal)
    // ENTR behavior:
    //   - Saves old B register to PREVB (Memory[new_B - 127])
    //   - Saves return address to LINK (Memory[new_B - 128])
    //   - Allocates stack space based on next word in memory
    //   - Updates stack pointers
    if (operand == 0140135) {
        return true;
    }

    return false;
}

/// @brief Detect if current instruction sequence is a C function epilogue
/// @param pc Program counter
/// @return true if looks like C function exit
/// @note Detects LEAVE/ELEAV which return via stack LINK (paired with ENTR)
static bool is_c_function_epilogue(uint16_t pc)
{
    // Read the instruction at current PC
    uint16_t operand = ReadVirtualMemory(pc, false);

    // LEAVE instruction - Normal return from structured stack frame
    // Opcode: 0140136 (octal)
    // Behavior: P = Memory[B-128] (LINK), B = Memory[B-127] (PREVB)
    // Used with ENTR to manage stack frames
    if (operand == 0140136) {
        return true;
    }

    // ELEAV instruction - Error return from structured stack frame
    // Opcode: 0140137 (octal)
    // Behavior: Similar to LEAVE but takes error return path
    // Also restores from stack LINK and PREVB
    if (operand == 0140137) {
        return true;
    }

    // Note: EXIT (0146142) is NOT included here
    // EXIT returns via L register (JPL calling convention)
    // LEAVE/ELEAV return via stack LINK (ENTR calling convention)

    return false;
}

/// @brief Find the memory address of the return address of the current stack frame.
/// @return The memory address of the return address of the current stack frame. -1 if no return address is found.
int32_t find_stack_return_address()
{
    // Check if we have any frames at all
    if (stack_trace.frame_count == 0)
    {
        // No frames, so we can't find a return address
        return -1;
    }

    // Get the return address of the previous frame
    return stack_trace.frames[stack_trace.current_frame].return_address;
}

/// @brief Update the entry point of the JPL instruction
/// @param pc Program counter of the JPL instruction
/// @param operand Operand of the JPL instruction
void debugger_update_jpl_entrypoint(uint16_t ea)
{
    if (stack_trace.frame_count == 0)
    {
        return;
    }

    // Update the entry point of the JPL instruction
    stack_trace.frames[stack_trace.current_frame].entry_point = ea;
}

/// @brief Called by the CPU before executing an instruction
/// @details This function is called by the CPU before executing an instruction.
/// It builds the stack trace and sends it to the DAP server.
void debugger_build_stack_trace(uint16_t pc, uint16_t operand)
{

    // Check for different call types
    bool is_jpl = ((operand & 0xF800) == 0134000);
    bool is_exit = (operand == 0146142);
    
    // NEW: Check for C calling convention (will be filled in after investigation)
    bool is_c_call = is_c_function_prologue(pc);
    bool is_c_return = is_c_function_epilogue(pc);

    // Is this the first frame?
    if (stack_trace.frame_count == 0)
    {
        stack_trace.frame_count = 1;
        stack_trace.current_frame = 0;

        // Add the root frame to our circular buffer
        stack_trace.frames[stack_trace.current_frame].operand = operand;
        stack_trace.frames[stack_trace.current_frame].return_address = pc;
        stack_trace.frames[stack_trace.current_frame].entry_point = pc;
        stack_trace.frames[stack_trace.current_frame].pc = pc;
    }

    // Handle function calls (JPL or C calling convention)
    if (is_jpl || is_c_call)
    {
        // Create new stack frame
        // Calculate the return address (next instruction after call)
        uint16_t return_address = pc + 1;  // Both JPL and typical C calls return to next instruction

        stack_trace.current_frame = (stack_trace.current_frame + 1) % MAX_STACK_FRAMES;
        if (stack_trace.frame_count < MAX_STACK_FRAMES)
        {
            stack_trace.frame_count++;
        }

        // Add the new frame to our circular buffer
        stack_trace.frames[stack_trace.current_frame].pc = pc;
        stack_trace.frames[stack_trace.current_frame].operand = operand;
        stack_trace.frames[stack_trace.current_frame].return_address = return_address;
        stack_trace.frames[stack_trace.current_frame].entry_point = 0; // the address where JPL will jump to (will be updated when JPL is executed)

        return;
    }
    // Handle function returns (EXIT or C return)
    else if (is_exit || is_c_return)
    {
        // Remove the last frame from stack
        if (stack_trace.frame_count > 1)
        {
            // Clear the current frame
            stack_trace.frames[stack_trace.current_frame].pc = 0;
            stack_trace.frames[stack_trace.current_frame].operand = 0;
            stack_trace.frames[stack_trace.current_frame].return_address = 0;
            stack_trace.frames[stack_trace.current_frame].entry_point = 0;

            // Move back one frame
            stack_trace.current_frame = (stack_trace.current_frame - 1 + MAX_STACK_FRAMES) % MAX_STACK_FRAMES;
            stack_trace.frame_count--;
        }

        return;
    }
    else
    {
        stack_trace.frames[stack_trace.current_frame].pc = pc;
    }
}

/// @brief Step the CPU by the given step type
/// @param server The DAP server instance
/// @param step_type The type of step to take
/// @return 0 on success, -1 on failure
int step_cpu(DAPServer *server, StepType step_type)
{
    if (!server)
    {
        return -1;
    }

    uint16_t current_pc = gPC;
    uint16_t target_pc = 0;
    bool stepping_to_line = false;

    // Access the step command context
    StepCommandContext *ctx = &server->current_command.context.step;

    char log_message[256];

    // Step over - step to next line (F10)
    if (step_type == STEP_OVER)
    {

        // Implement special handling for EXIT instruction
        if (gReg->myreg_IR == 014614)
        {
            // Set a temporary breakpoint at the return address
            int return_address = find_stack_return_address();
            if (return_address < 0)
                return -1;

            breakpoint_manager_add(return_address, BP_TYPE_TEMPORARY, NULL, NULL, NULL);
            ensure_cpu_running();
            return 0;
        }

        // Implement special handling for JMP, Conditional Jumps and SKP
        if (cpu_instruction_is_jump())
        {
            // Tell breakpoint manager to step one instruction
            breakpoint_manager_step_one();
            ensure_cpu_running();
            return 0;
        }
        
        // NEW: Check if current instruction is a procedure call
        uint16_t current_operand = ReadVirtualMemory(current_pc, false);
        if (is_procedure_call(current_operand)) {
            // For Step Over, we want to step OVER the call, not into it
            // Set breakpoint at return address (next instruction after call)
            uint16_t return_addr = current_pc + 1;  // JPL is 1 word
            
            snprintf(log_message, sizeof(log_message),
                    "Stepping over function call, return at %06o\n", return_addr);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_message);
            
            breakpoint_manager_add(return_addr, BP_TYPE_TEMPORARY, NULL, NULL, NULL);
            ensure_cpu_running();
            return 0;
        }

        // If we have symbol table and want to step by line
        // CRITICAL FIX: Check STABS first, then MAP
        if ((symbol_tables.symbol_table_stabs || symbol_tables.symbol_table_map) && 
            ((ctx->granularity == DAP_STEP_GRANULARITY_LINE) || (ctx->granularity == DAP_STEP_GRANULARITY_STATEMENT)))
        {
            // Try STABS first (for C programs with STABS debug info)
            if (symbol_tables.symbol_table_stabs) {
                target_pc = symbols_get_next_line_address(symbol_tables.symbol_table_stabs, current_pc);
                
                if (target_pc != 0 && target_pc != current_pc) {
                    stepping_to_line = true;
                    snprintf(log_message, sizeof(log_message),
                            "Stepping to next line at address %06o (from STABS)\n", target_pc);
                    dap_server_send_output(server, log_message);
                }
            }
            
            // Try MAP if STABS didn't work (for assembly programs)
            if ((!stepping_to_line) && symbol_tables.symbol_table_map) {
                target_pc = symbols_get_next_line_address(symbol_tables.symbol_table_map, current_pc);
                
                if (target_pc != 0 && target_pc != current_pc) {
                    stepping_to_line = true;
                    snprintf(log_message, sizeof(log_message),
                            "Stepping to next line at address %06o (from MAP)\n", target_pc);
                    dap_server_send_output(server, log_message);
                }
            }
        }

        // Set a temporary breakpoint at the target address if we're stepping to a line
        if (stepping_to_line && target_pc != 0 && target_pc != current_pc)
        {
            snprintf(log_message, sizeof(log_message), "Setting temporary breakpoint at address %06o\n", target_pc);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_message);

            // Use the CPU's breakpoint system to set a temporary breakpoint
            // This breakpoint will be automatically removed when hit
            breakpoint_manager_add(target_pc, BP_TYPE_TEMPORARY, NULL, NULL, NULL);
        }
        else
        {
            // Tell breakpoint manager to step one instruction
            breakpoint_manager_step_one();
        }

        ensure_cpu_running();
        return 0;
    }

    // Step in - intelligent source-level stepping (F11)
    if (step_type == STEP_IN)
    {
        snprintf(log_message, sizeof(log_message), "Step In from %06o\n", current_pc);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_message);
        
        // Check granularity - are we stepping by line or instruction?
        bool is_line_granularity = 
            (ctx->granularity == DAP_STEP_GRANULARITY_LINE) || 
            (ctx->granularity == DAP_STEP_GRANULARITY_STATEMENT);
        
        if (is_line_granularity) {
            // Source-level Step In
            
            // Get the current instruction
            uint16_t current_operand = ReadVirtualMemory(current_pc, false);
            
            // Check if this is a procedure call
            if (is_procedure_call(current_operand)) {
                // Calculate where the call will jump to
                uint16_t call_target = get_jpl_target_address(current_pc, current_operand);
                
                if (call_target != 0) {
                    // Try to find the first source line in the called function
                    int target_line = 0;
                    const char *target_file = NULL;
                    
                    // Try STABS first (for C functions)
                    if (symbol_tables.symbol_table_stabs) {
                        target_line = symbols_get_line(symbol_tables.symbol_table_stabs, call_target);
                        target_file = symbols_get_file(symbol_tables.symbol_table_stabs, call_target);
                    }
                    
                    // Try MAP if STABS didn't work (for assembly functions)
                    if ((!target_line || !target_file) && symbol_tables.symbol_table_map) {
                        target_line = symbols_get_line(symbol_tables.symbol_table_map, call_target);
                        target_file = symbols_get_file(symbol_tables.symbol_table_map, call_target);
                    }
                    
                    if (target_line && target_file) {
                        // Found source info - step into the function
                        snprintf(log_message, sizeof(log_message),
                                "Stepping into %s:%d (address %06o)\n", 
                                target_file, target_line, call_target);
                        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_message);
                        
                        // Set temporary breakpoint at function entry
                        breakpoint_manager_add(call_target, BP_TYPE_TEMPORARY, NULL, NULL, NULL);
                        ensure_cpu_running();
                        return 0;
                    }
                    
                    // No source info - still step into, but at instruction level
                    snprintf(log_message, sizeof(log_message),
                            "Stepping into function at %06o (no source info)\n", call_target);
                    dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_message);
                    
                    breakpoint_manager_add(call_target, BP_TYPE_TEMPORARY, NULL, NULL, NULL);
                    ensure_cpu_running();
                    return 0;
                }
            }
            
            // Not a call - step to next source line in current function
            uint16_t next_line_addr = 0;
            
            // Try STABS first
            if (symbol_tables.symbol_table_stabs) {
                next_line_addr = symbols_get_next_line_address(symbol_tables.symbol_table_stabs, current_pc);
            }
            
            // Try MAP if STABS didn't work
            if ((!next_line_addr || next_line_addr == current_pc) && symbol_tables.symbol_table_map) {
                next_line_addr = symbols_get_next_line_address(symbol_tables.symbol_table_map, current_pc);
            }
            
            if (next_line_addr && next_line_addr != current_pc) {
                snprintf(log_message, sizeof(log_message),
                        "Stepping to next line at %06o\n", next_line_addr);
                dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_message);
                
                breakpoint_manager_add(next_line_addr, BP_TYPE_TEMPORARY, NULL, NULL, NULL);
                ensure_cpu_running();
                return 0;
            }
        }
        
        // Fallback: instruction-level step
        snprintf(log_message, sizeof(log_message), 
                "Step In (instruction level) from %06o\n", current_pc);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_message);
        
        breakpoint_manager_step_one();
        ensure_cpu_running();
        return 0;
    }

    // Step out - step to the next return address (Shift+F11)
    if (step_type == STEP_OUT)
    {
        // Step out - step to the next return address
        uint16_t return_address = find_stack_return_address();
        if (return_address != -1)
        {
            breakpoint_manager_add(return_address, BP_TYPE_TEMPORARY, NULL, NULL, NULL);
            ensure_cpu_running();
            return 0;
        }
    }

    return -1;
}

/********************************** HELPER FUNCTIONS **********************************/

/// @brief Check if a string ends with a specific suffix
/// @param str The string to check
/// @param suffix The suffix to look for
/// @return true if str ends with suffix, false otherwise
static bool str_ends_with(const char *str, const char *suffix)
{
    if (!str || !suffix) return false;
    
    size_t str_len = strlen(str);
    size_t suffix_len = strlen(suffix);
    
    if (suffix_len > str_len) return false;
    
    return strcmp(str + str_len - suffix_len, suffix) == 0;
}

/// @brief Check if a file exists on disk
/// @param filepath Path to the file
/// @return true if file exists, false otherwise
static bool file_exists(const char *filepath)
{
    if (!filepath) return false;
    
    FILE *f = fopen(filepath, "r");
    if (f) {
        fclose(f);
        return true;
    }
    return false;
}

/// @brief Get or create a source reference for a file
/// @param filepath Path to the source file
/// @return Source reference ID (> 0) or 0 on error
static int get_or_create_source_reference(const char *filepath)
{
    if (!filepath) return 0;
    
    // Check if we already have a reference for this file
    for (int i = 0; i < source_ref_count; i++) {
        if (source_refs[i].filepath && strcmp(source_refs[i].filepath, filepath) == 0) {
            return source_refs[i].sourceReference;
        }
    }
    
    // Create new reference
    source_ref_count++;
    source_refs = realloc(source_refs, source_ref_count * sizeof(SourceReferenceMap));
    if (!source_refs) {
        source_ref_count--;
        return 0;
    }
    
    int idx = source_ref_count - 1;
    source_refs[idx].sourceReference = next_source_ref++;
    source_refs[idx].filepath = strdup(filepath);
    source_refs[idx].content = NULL;  // Load on demand
    
    return source_refs[idx].sourceReference;
}

/// @brief Load source file content by reference
/// @param sourceReference The source reference ID
/// @return File content (caller must free) or NULL on error
static char *load_source_file_by_reference(int sourceReference)
{
    // Find the source reference
    for (int i = 0; i < source_ref_count; i++) {
        if (source_refs[i].sourceReference == sourceReference) {
            // Return cached content if available
            if (source_refs[i].content) {
                return strdup(source_refs[i].content);
            }
            
            // Load from file
            if (source_refs[i].filepath) {
                FILE *f = fopen(source_refs[i].filepath, "r");
                if (!f) return NULL;
                
                // Get file size
                fseek(f, 0, SEEK_END);
                long size = ftell(f);
                fseek(f, 0, SEEK_SET);
                
                // Read content
                char *content = malloc(size + 1);
                if (content) {
                    fread(content, 1, size, f);
                    content[size] = '\0';
                    
                    // Cache it
                    source_refs[i].content = strdup(content);
                }
                
                fclose(f);
                return content;
            }
        }
    }
    
    return NULL;
}

/// @brief Free all source references
static void free_source_references(void)
{
    for (int i = 0; i < source_ref_count; i++) {
        if (source_refs[i].filepath) free(source_refs[i].filepath);
        if (source_refs[i].content) free(source_refs[i].content);
    }
    if (source_refs) free(source_refs);
    source_refs = NULL;
    source_ref_count = 0;
}

/********************************** CALLBACKS **********************************/

/**
 * @brief Step Next command handler
 *
 * Handles the 'next' command by stepping over the current line/statement
 * VS Code F10
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_next(DAPServer *server)
{
    return step_cpu(server, STEP_OVER);
}

/**
 * @brief Step In command handler
 *
 * Handles the 'stepIn' command by stepping into a function call
 * VS Code F11
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_step_in(DAPServer *server)
{
    return step_cpu(server, STEP_IN);
}

/**
 * @brief Step Out command handler
 *
 * Handles the 'stepOut' command by stepping out of the current function
 * VS Code Shift+F11
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_step_out(DAPServer *server)
{
    return step_cpu(server, STEP_OUT);
}

static int cmd_continue(DAPServer *server)
{

    CPURunMode run_mode = get_cpu_run_mode();
    if ((run_mode == CPU_PAUSED) || (run_mode == CPU_BREAKPOINT))
    {
        set_cpu_run_mode(CPU_RUNNING);
        return 0;
    }

    return 1; // Error
}

/**
 * @brief Handle DAP scopes request
 *
 * This function creates scope objects for the variables visible in the current stack frame.
 * It defines several scopes:
 * 1. Locals - Local variables
 * 2. CPU Registers - CPU register values
 * 3. Memory - Memory regions
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_scopes(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    // Extract frame_id from the command context
    int frame_id = server->current_command.context.scopes.frame_id;

    // Allocate memory for the scopes
    DAPScope *scopes = (DAPScope *)calloc(NUM_SCOPES, sizeof(DAPScope));
    if (!scopes)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                        "Error: Failed to allocate memory for scopes\n");
        return -1;
    }

    // Set up Locals scope
    int scope_index = 0;

    if (stack_trace.frames[stack_trace.current_frame].variables.number_of_variables > 0)
    {
        scopes[scope_index].name = strdup("Locals");
        scopes[scope_index].variables_reference = SCOPE_ID_LOCALS;
        scopes[scope_index].named_variables = stack_trace.frames[stack_trace.current_frame].variables.number_of_variables; // Number of local variables
        scopes[scope_index].indexed_variables = 0;
        scopes[scope_index].expensive = false;
        // Source location fields are optional, set to 0/NULL
        scopes[scope_index].source_path = NULL;
        scopes[scope_index].line = 0;
        scopes[scope_index].column = 0;
        scopes[scope_index].end_line = 0;
        scopes[scope_index].end_column = 0;
        scope_index++;
    }

    // Set up CPU Registers scope
    scopes[scope_index].name = strdup("CPU Registers");
    scopes[scope_index].variables_reference = SCOPE_ID_REGISTERS;
    scopes[scope_index].named_variables = 9; // STS, D, P, B, L, A, T, X + EA
    scopes[scope_index].indexed_variables = 0;
    scopes[scope_index].expensive = false;
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;

    // Set up Levels registers
    scope_index++;
    scopes[scope_index].name = strdup("Interrupt levels");
    scopes[scope_index].variables_reference = SCOPE_ID_LEVELS;
    scopes[scope_index].named_variables = 0; // 16 levels + PIL/PVL
    scopes[scope_index].indexed_variables = 0;
    scopes[scope_index].expensive = false;
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;

    // Set up Internal Registers - Read scope
    scope_index++;
    scopes[scope_index].name = strdup("Internal Registers - Read");
    scopes[scope_index].variables_reference = SCOPE_ID_INTERNAL_REGISTERS_READ;
    scopes[scope_index].named_variables = 1; // 13 internal register
    scopes[scope_index].indexed_variables = 0;
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;

    // Set up Internal Registers - Write scope
    scope_index++;
    scopes[scope_index].name = strdup("Internal Registers - Write");
    scopes[scope_index].variables_reference = SCOPE_ID_INTERNAL_REGISTERS_WRITE;
    scopes[scope_index].named_variables = 10; // num internal registers
    scopes[scope_index].indexed_variables = 0;
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;

    // Set up Memory scope
    scope_index++;
    scopes[scope_index].name = strdup("MMS");
    scopes[scope_index].variables_reference = SCOPE_ID_MEM_MMS;
    scopes[scope_index].named_variables = 3; // Number of memory regions
    scopes[scope_index].indexed_variables = 0;
    scopes[scope_index].expensive = true; // Memory access is expensive
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;

    // Store the scopes in the command context for the DAP server to use
    server->current_command.context.scopes.scopes = scopes;
    server->current_command.context.scopes.scope_count = NUM_SCOPES;

    return 0;
}

/**
 * @brief Helper function to add a variable to the server's variable array
 *
 * @param server The DAP server instance
 * @param name Variable name
 * @param value Variable value
 * @param type Variable type
 * @param variables_reference Reference for child variables (0 for leaf variables)
 * @param memory_reference Optional memory reference
 * @param kind Enum of variable kind (property, method, etc.)
 * @param attributes Enum of attributes
 * @return DAPVariable* Pointer to the newly added variable or NULL on failure
 */
static DAPVariable *add_variable_to_array(
    DAPServer *server,
    const char *name,
    const char *value,
    const char *type,
    uint32_t memory_reference,

    int variables_reference,
    DAPVariableKind kind,
    DAPVariableAttributes attributes)
{
    if (!server || !name || !value)
    {
        return NULL;
    }

    // Increase the count and reallocate the array
    server->current_command.context.variables.variable_count++;
    server->current_command.context.variables.variable_array = realloc(
        server->current_command.context.variables.variable_array,
        server->current_command.context.variables.variable_count * sizeof(DAPVariable));

    if (!server->current_command.context.variables.variable_array)
    {
        server->current_command.context.variables.variable_count--;
        return NULL;
    }

    // Get a pointer to the newly added variable
    DAPVariable *var = &server->current_command.context.variables.variable_array[server->current_command.context.variables.variable_count - 1];

    // Initialize the variable with the provided values
    var->name = name ? strdup(name) : NULL;
    var->value = value ? strdup(value) : NULL;
    var->type = type ? strdup(type) : NULL;
    var->memory_reference = memory_reference;
    var->variables_reference = variables_reference;
    var->named_variables = 0;
    var->indexed_variables = 0;
    var->evaluate_name = NULL;

    var->presentation_hint.kind = kind;
    var->presentation_hint.attributes = attributes;
    var->presentation_hint.visibility = DAP_VARIABLE_VISIBILITY_NONE;

    return var;
}

/**
 * @brief Add local variables to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_local_variables(DAPServer *server, char *info_message, size_t info_message_size)
{

    // No local variables in this example, but in a real implementation
    // this would add variables from the current stack frame

    // Property kind for all variables
    const char *property_kind = "property";
    const char *no_attributes[] = {NULL};

    // Example dummy variable
    add_variable_to_array(
        server,
        "dummy",                    // name
        "0",                        // value
        "integer",                  // type
        0,                          // variablesReference
        0,                          // memoryReference (no memory reference for locals)
        DAP_VARIABLE_KIND_PROPERTY, // kind
        DAP_VARIABLE_ATTR_NONE      // attributes
    );
}

static void add_level_variables(DAPServer *server, char *info_message, size_t info_message_size)
{

    char value_str[100];

    // ADD PIL
    snprintf(value_str, sizeof(value_str), "%06o", gPIL);
    add_variable_to_array(
        server,
        "PIL",                      // name
        value_str,                  // value
        "integer",                  // type
        0,                          // variablesReference
        0,                          // memoryReference (no memory reference for locals)
        DAP_VARIABLE_KIND_PROPERTY, // kind
        DAP_VARIABLE_ATTR_NONE      // attributes
    );

    // ADD PVL
    snprintf(value_str, sizeof(value_str), "%06o", gPVL);
    add_variable_to_array(
        server,
        "PVL",                      // name
        value_str,                  // value
        "integer",                  // type
        0,                          // variablesReference
        0,                          // memoryReference (no memory reference for locals)
        DAP_VARIABLE_KIND_PROPERTY, // kind
        DAP_VARIABLE_ATTR_NONE      // attributes
    );

    for (int i = 0; i < 16; i++)
    {
        ushort rP = gReg->reg[i][_P];
        ushort rPCR = gReg->reg_PCR[i];
        ushort pt = 0, apt = 0;

        // decode PCR
        ushort ring = rPCR & 0x03;
        if (rPCR & (1 << 2))
        {
            // Sixteen page table mode
            pt = (rPCR >> 11) & 0x0F;
            apt = (rPCR >> 7) & 0x0F;
        }
        else
        {
            // Four page table mode
            pt = (rPCR >> 9) & 0x03;
            apt = (rPCR >> 7) & 0x03;
        }
        ushort priority = (rPCR >> 2) & 0x07;
        char value_str[100];
        sprintf(value_str, "Ring[%d] PT[%d] APT[%d] P[%06d]", ring, pt, apt, rP);

        char name[20];
        sprintf(name, "Level %d", i);

        char memory_reference[100];
        sprintf(memory_reference, "0x%04x", rP);

        add_variable_to_array(
            server,
            name,                   // name
            value_str,              // value
            "integer",              // type
            rP,                     // memoryReference
            0,                      // variablesReference
            DAP_VARIABLE_KIND_DATA, // kind
            DAP_VARIABLE_ATTR_NONE  // attributes
        );
    }
}

/**
 * @brief Add CPU register variables to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_register_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    snprintf(info_message, info_message_size,
             "Loading CPU registers\n");

    // Property kind with no attributes
    const char *property_kind = "property";

    server->current_command.context.variables.variable_count = 0;

    // Register formatting
    char value_str[32];

    // Add the ST register (Status register)
    snprintf(value_str, sizeof(value_str), "%06o", gSTSr);
    DAPVariable *var = add_variable_to_array(
        server,
        "STS",     // name
        value_str, // value
        //"bitmap",                  // type
        "integer",
        -1,                     // memoryReference  (-1 = not present)
        SCOPE_ID_STATUS_FLAGS,  // variablesReference
        DAP_VARIABLE_KIND_DATA, // kind
        DAP_VARIABLE_ATTR_NONE  // attributes
    );

    // Add the D register (Data register)
    snprintf(value_str, sizeof(value_str), "%06o", gD);
    add_variable_to_array(
        server,
        "D",                    // name
        value_str,              // value
        "integer",              // type
        gD,                     // memoryReference
        0,                      // variablesReference
        DAP_VARIABLE_KIND_DATA, // kind
        DAP_VARIABLE_ATTR_NONE  // attributes
    );

    // Add the P register (Program Counter)
    snprintf(value_str, sizeof(value_str), "%06o", gPC);
    add_variable_to_array(
        server,
        "P",                    // name
        value_str,              // value
        "integer",              // type
        gPC,                    // memoryReference
        0,                      // variablesReference
        DAP_VARIABLE_KIND_DATA, // kind
        DAP_VARIABLE_ATTR_NONE  // attributes
    );

    // Add the B register (B register)
    snprintf(value_str, sizeof(value_str), "%06o", gB);
    add_variable_to_array(
        server,
        "B",                    // name
        value_str,              // value
        "integer",              // type
        gB,                     // memoryReference
        0,                      // variablesReference
        DAP_VARIABLE_KIND_DATA, // kind
        DAP_VARIABLE_ATTR_NONE  // attributes
    );

    // Add the L register (Link register)
    snprintf(value_str, sizeof(value_str), "%06o", gL);
    add_variable_to_array(
        server,
        "L",                    // name
        value_str,              // value
        "integer",              // type
        gL,                     // memoryReference
        0,                      // variablesReference
        DAP_VARIABLE_KIND_DATA, // kind
        DAP_VARIABLE_ATTR_NONE  // attributes
    );

    // Add the A register (Accumulator)
    snprintf(value_str, sizeof(value_str), "%06o", gA);
    add_variable_to_array(
        server,
        "A",                    // name
        value_str,              // value
        "integer",              // type
        gA,                     // memoryReference
        0,                      // variablesReference
        DAP_VARIABLE_KIND_DATA, // kind
        DAP_VARIABLE_ATTR_NONE  // attributes
    );

    // Add the T register (T register)
    snprintf(value_str, sizeof(value_str), "%06o", gT);
    add_variable_to_array(
        server,
        "T",                    // name
        value_str,              // value
        "integer",              // type
        gT,                     // memoryReference
        0,                      // variablesReference
        DAP_VARIABLE_KIND_DATA, // kind
        DAP_VARIABLE_ATTR_NONE  // attributes
    );

    // Add the X register (Index register)
    snprintf(value_str, sizeof(value_str), "%06o", gX);
    add_variable_to_array(
        server,
        "X",                    // name
        value_str,              // value
        "integer",              // type
        gX,                     // memoryReference
        0,                      // variablesReference
        DAP_VARIABLE_KIND_DATA, // kind
        DAP_VARIABLE_ATTR_NONE  // attributes
    );

    // Add the Effective address register
    snprintf(value_str, sizeof(value_str), "%06o", gEA);
    add_variable_to_array(
        server,
        "EA",                   // name
        value_str,              // value
        "integer",              // type
        gEA,                    // memoryReference
        0,                      // variablesReference
        DAP_VARIABLE_KIND_DATA, // kind
        DAP_VARIABLE_ATTR_NONE  // attributes
    );
}

/**
 * @brief Add internal CPU register variables to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_internal_registers_read_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    snprintf(info_message, info_message_size,
             "Loading internal CPU registers\n");

    // Property kind with readonly attribute
    const char *property_kind = "property";
    const char *readonly_attrs[] = {"readOnly"};

    server->current_command.context.variables.variable_count = 0;

    // Register formatting
    char value_str[32];

    // Define the internal registers with their addresses
    struct
    {
        const char *name;
        uint16_t *reg_ptr;
        const char *type;
    } internal_regs[] = {
        {"PANS", &gReg->reg_PANS, "octal"}, // Panel status
        {"OPR", &gReg->reg_OPR, "octal"},   // Operator register
        {"PGS", &gReg->reg_PGS, "octal"},   // Paging status register
        {"PVL", &gReg->reg_PVL, "octal"},   // Page violation limit register
        {"IIC", &gReg->reg_IIC, "octal"},   // Internal interrupt code register
        {"IID", &gReg->reg_IID, "octal"},   // Internal interrupt detect register
        {"PID", &gReg->reg_PID, "octal"},   // Priority interrupt detect register
        {"PIE", &gReg->reg_PIE, "octal"},   // Priority interrupt enable register
        {"CSR", &gReg->reg_CSR, "octal"},   // Control store register
        {"ALD", &gReg->reg_ALD, "octal"},   // Auto-load descriptor register
        {"PES", &gReg->reg_PES, "octal"},   // Page error status register
        {"PGC", &gReg->reg_PGC, "octal"},   // Paging Control Register
        {"PEA", &gReg->reg_PEA, "octal"},   // Page error address register
    };

    const int num_regs = sizeof(internal_regs) / sizeof(internal_regs[0]);

    // Add each internal register to the variable array
    for (int i = 0; i < num_regs; i++)
    {
        // Format the register value in octal
        snprintf(value_str, sizeof(value_str), "%06o", *(internal_regs[i].reg_ptr));

        // Add the register to the variable array
        add_variable_to_array(
            server,
            internal_regs[i].name,  // name
            value_str,              // value
            internal_regs[i].type,  // type
            -1,                     // memoryReference - safely truncate to 32-bit if needed
            0,                      // variablesReference (no children)
            DAP_VARIABLE_KIND_DATA, // kind
            DAP_VARIABLE_ATTR_NONE  // attributes
        );
    }
}

/**
 * @brief Add internal CPU register variables to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_internal_registers_write_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    snprintf(info_message, info_message_size,
             "Loading internal CPU registers\n");

    // Property kind with readonly attribute
    const char *property_kind = "property";

    server->current_command.context.variables.variable_count = 0;

    // Register formatting
    char value_str[32];

    // Define the internal registers with their addresses
    struct
    {
        const char *name;
        uint16_t *reg_ptr;
        const char *type;
    } internal_regs[] = {
        {"PANC", &gReg->reg_PANC, "octal"},     // Panel control
        {"LMP", &gReg->reg_LMP, "octal"},       // Panel data display buffer register
        {"PCR", &gReg->reg_PCR[gPIL], "octal"}, // Paging Control Register
        {"IIE", &gReg->reg_IIE, "octal"},       // Internal interrupt enable register
        {"PID", &gReg->reg_PID, "octal"},       // Priority interrupt detect register
        {"PIE", &gReg->reg_PIE, "octal"},       // Priority interrupt enable register
        {"CCL", &gReg->reg_CCL, "octal"},       // Cache clear register
        {"LCIL", &gReg->reg_LCIL, "octal"},     // Lower cache inhibit limit register
        {"UCIL", &gReg->reg_UCIL, "octal"},     // Upper cache inhibit limit register
        {"ECCR", &gReg->reg_ECCR, "octal"},     // Error correction control register
    };

    const int num_regs = sizeof(internal_regs) / sizeof(internal_regs[0]);

    // Add each internal register to the variable array
    for (int i = 0; i < num_regs; i++)
    {
        // Format the register value in octal
        snprintf(value_str, sizeof(value_str), "%06o", *(internal_regs[i].reg_ptr));

        // Add the register to the variable array
        add_variable_to_array(
            server,
            internal_regs[i].name,  // name
            value_str,              // value
            internal_regs[i].type,  // type
            -1,                     // memoryReference (-1 = not present)
            0,                      // variablesReference (no children)
            DAP_VARIABLE_KIND_DATA, // kind
            DAP_VARIABLE_ATTR_NONE  // attributes
        );
    }
}
/**
 * @brief Add status flags from the STS register to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_status_flag_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    snprintf(info_message, info_message_size,
             "Loading CPU status flags\n");

    // Property kind with readonly attribute
    const char *property_kind = "property";
    const char *readonly_attrs[] = {"readOnly"};

    server->current_command.context.variables.variable_count = 0;

    // Status flag definitions with bit positions
    struct
    {
        const char *name;
        int bit_pos;
    } status_flags[] = {
        {"P", 0},      // Page Table Mode
        {"T", 1},      // Rounging flag for floating point operations
        {"K", 2},      // One bit accumulato
        {"Z", 3},      // Error flag
        {"Q", 4},      // Dynamic overflow flag
        {"O", 5},      // Overflow flag
        {"C", 6},      // Carry flag
        {"M", 7},      // Multishift flag
        {"PIL", 8},    // Program level
        {"N100", 12},  // N100 flag (always 1)
        {"SEXI", 13},  // Extended flag
        {"PONI", 14},  // Memory management on flag
        {"IONI", 15}}; // Interrupt system on flag

    const int num_flags = sizeof(status_flags) / sizeof(status_flags[0]);

    // Get the current STS register value
    uint16_t sts_value = gSTSr;

    // Add each flag to the variable array
    for (int i = 0; i < num_flags; i++)
    {
        // Get the bit value (special handling for PL which is 4 bits)
        bool value;
        char value_str[32];

        if (strcmp(status_flags[i].name, "PIL") == 0)
        {
            // Extract 4-bit PL field
            int pl_value = (sts_value >> 8) & 0x0F;
            snprintf(value_str, sizeof(value_str), "%d", pl_value);
        }
        else
        {
            // Extract 1-bit flags
            value = (sts_value >> status_flags[i].bit_pos) & 0x01;
            snprintf(value_str, sizeof(value_str), "%d", value);
        }

        // Create a display name with description
        char display_name[64];
        snprintf(display_name, sizeof(display_name), "%s",
                 status_flags[i].name);

        // Add the flag to the variable array
        add_variable_to_array(
            server,
            display_name,                                                     // name with description
            value_str,                                                        // value (true/false or numeric for PL)
            strcmp(status_flags[i].name, "PIL") == 0 ? "integer" : "boolean", // type
            -1,                                                               // memoryReference (-1 = not present)
            0,                                                                // variablesReference (no children)
            DAP_VARIABLE_KIND_PROPERTY,                                       // kind
            DAP_VARIABLE_ATTR_NONE                                            // attributes
        );
    }
}

/// @brief Get informaiton about a page table entry
/// @param PTe
/// @return
char *GetPageTableEntryInfo(uint32_t PTe)
{

    static char debugInfo[256];
    debugInfo[0] = '\0';

    char memoryRange[50];

    // Map to physical page
    ushort PPN = 0;
    if (STS_SEXI)
    {
        // Use lower 14-bit
        PPN = (ushort)(PTe & 0x3FFF);
    }
    else
    {
        // "normal" mode, use only the lower 9-bits
        PPN = (ushort)(PTe & 0x1FF);
    }

    PTe = PTe >> 16;

    if ((PTe & 1 << 15) != 0)
        strcat(debugInfo, "[WPM]");
    if ((PTe & 1 << 14) != 0)
        strcat(debugInfo, "[RPM]");
    if ((PTe & 1 << 13) != 0)
        strcat(debugInfo, "[FPM]");
    if ((PTe & 1 << 12) != 0)
        strcat(debugInfo, "[WIP]");
    if ((PTe & 1 << 11) != 0)
        strcat(debugInfo, "[PGU]");

    int ring = (int)((PTe >> 9) & 0x03);
    snprintf(debugInfo, sizeof(debugInfo), "[R:%d]", ring);

    char ppnStr[16];
    snprintf(ppnStr, sizeof(ppnStr), "[PPN:0x%04X]", PPN);
    strcat(debugInfo, ppnStr);

    uint32_t start = PPN << 10;
    uint32_t end = start | 0x3FFF;

    sprintf(memoryRange, " MEM[0x%06X:0x%06X]", start, end);
    strcat(debugInfo, memoryRange);

    return debugInfo;
}

char *GetPageTableMemoryRange(uint32_t PTe)
{
    static char debugInfo[256];
    debugInfo[0] = '\0';
    uint32_t PPN = 0;

    if (STS_SEXI)
    {
        // Use lower 14-bit
        PPN = (uint16_t)(PTe & 0x3FFF);
    }
    else
    {
        // "normal" mode, use only the lower 9-bits
        PPN = (uint16_t)(PTe & 0x1FF);
    }

    return debugInfo;
}

static void add_page_mms_entries(DAPServer *server, char *info_message, size_t info_message_size)
{

    // Property kind with readonly attribute
    const char *property_kind = "property";
    const char *no_attributes[] = {NULL};

    // Get PCR for current runlevel
    ushort rPCR = gReg->reg_PCR[gPIL];
    ushort pt = 0, apt = 0;
    PageTableMode ptm = Four; // Default to four page tables

    // decode PT and APT PCR
    ushort ring = rPCR & 0x03;
    if (rPCR & (1 << 2))
    {
        // Sixteen page table mode
        pt = (rPCR >> 11) & 0x0F;
        apt = (rPCR >> 7) & 0x0F;
        ptm = Sixteen;
    }
    else
    {
        // Four page table mode
        pt = (rPCR >> 9) & 0x03;
        apt = (rPCR >> 7) & 0x03;
        ptm = Four;
    }

    char display_name[64];
    if (pt == apt)
    {
        snprintf(display_name, sizeof(display_name), "PT %d APT %d", pt, apt);
    }
    else
    {
        snprintf(display_name, sizeof(display_name), "PT %d", pt);
    }

    char pt_str[32];
    snprintf(pt_str, sizeof(pt_str), "%d", pt);

    add_variable_to_array(
        server,
        display_name,               // name with description
        pt_str,                     // value
        "memory",                   // type
        -1,                         // memoryReference (-1 = not present)
        SCOPE_ID_MEM_PT,            // variablesReference (no children)
        DAP_VARIABLE_KIND_PROPERTY, // kind
        DAP_VARIABLE_ATTR_NONE      // attributes
    );

    if (apt != pt)
    {
        snprintf(display_name, sizeof(display_name), "APT %d", apt);
        snprintf(pt_str, sizeof(pt_str), "%d", pt);

        add_variable_to_array(
            server,
            display_name,               // name with description
            pt_str,                     // value
            "memory",                   // type
            -1,                         // memoryReference (-1 = not present)
            SCOPE_ID_MEM_APT,           // variablesReference (no children)
            DAP_VARIABLE_KIND_PROPERTY, // kind
            DAP_VARIABLE_ATTR_NONE      // attributes
        );
    }
}

/**
 * @brief Add page table entries to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_page_table_entries(DAPServer *server, char *info_message, size_t info_message_size, bool useAPT)
{

    // Property kind with readonly attribute
    const char *property_kind = "property";
    const char *no_attributes[] = {NULL};

    // Get PCR for current runlevel
    ushort rPCR = gReg->reg_PCR[gPIL];
    ushort pt = 0, apt = 0;
    PageTableMode ptm = Four; // Default to four page tables

    // decode PT and APT PCR
    ushort ring = rPCR & 0x03;
    if (rPCR & (1 << 2))
    {
        // Sixteen page table mode
        pt = (rPCR >> 11) & 0x0F;
        apt = (rPCR >> 7) & 0x0F;
        ptm = Sixteen;
    }
    else
    {
        // Four page table mode
        pt = (rPCR >> 9) & 0x03;
        apt = (rPCR >> 7) & 0x03;
        ptm = Four;
    }

    if (useAPT)
    {
        pt = apt;
    }

    for (int vpn = 0; vpn < 64; vpn++)
    {
        uint32_t pageTableEntry = GetPageTableEntry(pt, vpn, ptm);

        char vpn_str[32];
        snprintf(vpn_str, sizeof(vpn_str), "%d", vpn);

        add_variable_to_array(
            server,
            vpn_str,                                    // name
            GetPageTableEntryInfo(pageTableEntry), // value
            "memory",                                   // type
            -1,                                         // memoryReference (-1 = not present)
            0,                                          // variablesReference
            DAP_VARIABLE_KIND_PROPERTY,                 // kind
            DAP_VARIABLE_ATTR_NONE                      // attributes
        );
    }
}

/**
 * @brief Handle DAP variables request
 *
 * This function provides variables for the requested container (scope).
 * It creates variables based on CPU state, memory content, etc.
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_variables(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    // Extract variables reference from the command context
    int variables_reference = server->current_command.context.variables.variables_reference;

    // printf("Variables request for reference: %d\n", variables_reference);

    // Buffer for informational messages
    char info_message[256] = {0};

    // Reset variable array count
    server->current_command.context.variables.variable_count = 0;
    server->current_command.context.variables.variable_array = NULL;

    // Handle different variable reference types
    switch (variables_reference)
    {
    case SCOPE_ID_LOCALS:
    {
        if (stack_trace.frames[stack_trace.current_frame].variables.number_of_variables > 0)
        {
            // Use our helper function for local variables
            add_local_variables(server, info_message, sizeof(info_message));
        }
        break;
    }

    case SCOPE_ID_REGISTERS:
    {
        // Use our helper function for register variables
        add_register_variables(server, info_message, sizeof(info_message));
        break;
    }

    case SCOPE_ID_LEVELS:
    {
        // Use our helper function for level variables
        add_level_variables(server, info_message, sizeof(info_message));
        break;
    }
    case SCOPE_ID_INTERNAL_REGISTERS_READ:
    {
        // Use our helper function for internal registers variables
        add_internal_registers_read_variables(server, info_message, sizeof(info_message));
        break;
    }
    case SCOPE_ID_INTERNAL_REGISTERS_WRITE:
    {
        // Use our helper function for internal registers variables
        add_internal_registers_write_variables(server, info_message, sizeof(info_message));
        break;
    }

    case SCOPE_ID_STATUS_FLAGS:
    {
        // Use our helper function for status flag variables
        add_status_flag_variables(server, info_message, sizeof(info_message));
        break;
    }

    case SCOPE_ID_MEM_MMS:
    {
        // Fetch page table entries for PT
        add_page_mms_entries(server, info_message, sizeof(info_message));
        break;
    }

    case SCOPE_ID_MEM_PT:
    {
        // Fetch page table entries for PT
        add_page_table_entries(server, info_message, sizeof(info_message), false);
        break;
    }

    case SCOPE_ID_MEM_APT:
    {
        // Fetch page table entries for APT
        add_page_table_entries(server, info_message, sizeof(info_message), true);
        break;
    }

    default:
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, "Unknown variable reference\n");
        break;
    }

    // Output info message if we have one
    if (info_message[0] != '\0')
    {
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, info_message);
    }

    // The variables will be used by handle_variables and converted to JSON
    // We don't need to clean up here, as the caller (handle_variables) will handle it
    // This is intentional to allow the response to be sent before freeing the memory

    return 0;
}

/// @brief Update a DAP response stack frame with the given memory reference
/// @param server DAP server instance
/// @param frame_index Index of the frame in the stack trace
/// @param frame_id Unique ID of the frame
/// @param memory_reference Memory reference of the frame
/// @param entry_point Entry point of the frame
/// @return 0 on success, -1 on failure
void update_stack_frame(DAPServer *server, int frame_index, int frame_id, uint16_t memory_reference, uint16_t entry_point)
{
    // Initialize the frame
    DAPStackFrame *frame = &server->current_command.context.stack_trace.frames[frame_index];
    frame->id = frame_id;
    frame->name = NULL;
    frame->source_path = NULL;
    frame->source_name = NULL;
    frame->line = 0;
    frame->column = 0;
    frame->end_line = 0;
    frame->end_column = 0;
    frame->can_restart = false;
    frame->instruction_pointer_reference = -1; // -1 means no instruction pointer reference
    frame->module_id = NULL;
    frame->presentation_hint = DAP_FRAME_PRESENTATION_NORMAL;

    // Try to get symbol information if we have a symbol table
    // Get source location information
    int line = symbols_get_line(symbol_tables.symbol_table_map, memory_reference);
    const char *file = symbols_get_file(symbol_tables.symbol_table_map, memory_reference);
    const symbol_entry_t *symbol = symbols_lookup_by_address(symbol_tables.symbol_table_aout, entry_point);

    if (line > 0 && file)
    {
        // We found source information
        frame->line = line;
        frame->source_path = strdup(file);

        // Extract source name from path
        const char *name = strrchr(file, '/');
        if (name)
        {
            frame->source_name = strdup(name + 1);
        }
        else
        {
            frame->source_name = strdup(file);
        }

        // Create a frame name from the symbol or PC

        char frame_name[256];

        // If we have a symbol, use it to create a frame name
        if (symbol && symbol->name)
        {
            snprintf(frame_name, sizeof(frame_name), "%s at %06o", symbol->name, memory_reference);
        }
        else
        {
            // No symbol, use PC as frame name
            if (symbol && symbol->name)
            {
                snprintf(frame_name, sizeof(frame_name), "%s at %06o", symbol->name, memory_reference);
            }
            else
            {
                snprintf(frame_name, sizeof(frame_name), "frame at %06o", memory_reference);
            }
        }

        frame->name = strdup(frame_name);

        // Log the source mapping
        char log_msg[256];
        snprintf(log_msg, sizeof(log_msg), "PC %06o mapped to %s:%d\n",
                 memory_reference, file, line);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_msg);
    }
    else
    {
        // No source information found, use PC as frame name
        char frame_name[256];
        snprintf(frame_name, sizeof(frame_name), "frame at %06o", memory_reference);
        frame->name = strdup(frame_name);
    }

    // Set instruction pointer reference (Enables disassembly of the current instruction)
    frame->instruction_pointer_reference = memory_reference;
}

/**
 * @brief Handle DAP stackTrace request
 *
 * This function creates a stack trace response with the current call stack,
 * including source file locations and line numbers. In this implementation,
 * we create at least one stack frame for the current PC location.
 *
 * @param server The DAP server instance
 * @return int 0 on success, -1 on failure
 */
static int cmd_stack_trace(DAPServer *server)
{
    if (!server)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                        "Error: Invalid server instance\n");
        return -1;
    }

    // Validate stack trace availability
    if (stack_trace.frame_count == 0)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                        "No stack trace available\n");
        return -1;
    }

    // Extract and validate request parameters
    int stack_levels = server->current_command.context.stack_trace.levels;
    int stack_start_frame = server->current_command.context.stack_trace.start_frame;
    int frame_count = stack_trace.frame_count;

    // Validate input parameters
    if (stack_levels <= 0)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                        "Error: Invalid stack levels requested\n");
        return -1;
    }

    if (stack_start_frame < 0)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                        "Error: Invalid start frame requested\n");
        return -1;
    }

    // Calculate number of frames to return
    int frames_to_return = stack_levels;
    if (frames_to_return > (frame_count - stack_start_frame))
    {
        frames_to_return = frame_count - stack_start_frame;
    }

    // If no frames to return after calculations, return empty result
    if (frames_to_return <= 0)
    {
        server->current_command.context.stack_trace.frame_count = 0;
        server->current_command.context.stack_trace.total_frames = frame_count;
        server->current_command.context.stack_trace.frames = NULL;
        return 0;
    }

    // Allocate memory for the stack frames
    server->current_command.context.stack_trace.frame_count = frames_to_return;
    server->current_command.context.stack_trace.total_frames = frame_count;
    server->current_command.context.stack_trace.frames = malloc(sizeof(DAPStackFrame) * frames_to_return);

    // Check for allocation failure
    if (!server->current_command.context.stack_trace.frames)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                        "Error: Failed to allocate memory for stack frames\n");
        return -1;
    }

    // Fill in the stack frames in reverse order (most recent first)
    for (int i = 0; i < frames_to_return; i++)
    {
        // Calculate frame index - we want to go from newest to oldest
        // current_frame points to the newest frame, so we start there and go backwards
        int frame_idx = (stack_trace.current_frame - i + MAX_STACK_FRAMES) % MAX_STACK_FRAMES;

        // For the currrent frame, update PC
        if (frame_idx == stack_trace.current_frame)
        {
            stack_trace.frames[frame_idx].pc = gPC;
        }

        uint16_t memory_reference = stack_trace.frames[frame_idx].pc;
        uint16_t entry_point = stack_trace.frames[frame_idx].entry_point;

        // Update frame with enhanced information
        DAPStackFrame *frame = &server->current_command.context.stack_trace.frames[i];
        frame->id = frame_idx;
        frame->name = NULL;
        frame->source_path = NULL;
        frame->source_name = NULL;
        frame->line = 0;
        frame->column = 0;
        frame->end_line = 0;
        frame->end_column = 0;
        frame->can_restart = false;
        frame->instruction_pointer_reference = memory_reference;
        frame->module_id = NULL;
        frame->presentation_hint = DAP_FRAME_PRESENTATION_NORMAL;

        // symbols_dump_all(symbol_tables.symbol_table_aout);

        // Try to get symbol information
        const symbol_entry_t *symbol = symbols_lookup_by_address(symbol_tables.symbol_table_aout, entry_point);
        if (symbol && symbol->name)
        {
            frame->name = strdup(symbol->name);
            frame->valid_symbol = true;
            frame->symbol_entry_point = entry_point;
        }
        else
        {
            frame->name = strdup("<unknown>");
            frame->valid_symbol = false;
        }

        /*
        for (int i = 0; i < symbol_tables.symbol_table_aout->count; i++)
        {
            const symbol_entry_t *symbol = &symbol_tables.symbol_table_aout->entries[i];
            if (symbol->address == entry_point)
            {
                printf("Symbol found: %s at %06o\n", symbol->name, symbol->address);
            }
        }
        */

        // Get source location information - try multiple symbol tables
        int line = 0;
        const char *file = NULL;
        
        // Try MAP file first (most reliable for assembly)
        if (symbol_tables.symbol_table_map) {
            line = symbols_get_line(symbol_tables.symbol_table_map, memory_reference);
            file = symbols_get_file(symbol_tables.symbol_table_map, memory_reference);
        }
        
        // Try STABS if MAP didn't work
        if ((!line || !file) && symbol_tables.symbol_table_stabs) {
            line = symbols_get_line(symbol_tables.symbol_table_stabs, memory_reference);
            file = symbols_get_file(symbol_tables.symbol_table_stabs, memory_reference);
        }
        
        // Try AOUT as last resort
        if ((!line || !file) && symbol_tables.symbol_table_aout) {
            line = symbols_get_line(symbol_tables.symbol_table_aout, memory_reference);
            file = symbols_get_file(symbol_tables.symbol_table_aout, memory_reference);
        }

        if (line > 0 && file)
        {
            // We found source information
            frame->line = line;
            
            // Check if file exists on disk
            if (file_exists(file)) {
                // File exists - use path directly
                frame->source_path = strdup(file);
                // NOTE: source_reference field removed from DAPStackFrame in libdap
                // frame->source_reference = 0;
            } else {
                // File doesn't exist - use sourceReference
                frame->source_path = NULL;
                // NOTE: source_reference field removed from DAPStackFrame in libdap
                // frame->source_reference = get_or_create_source_reference(file);
            }

            // Extract source name from path
            const char *name = strrchr(file, '/');
            if (name)
            {
                frame->source_name = strdup(name + 1);
            }
            else
            {
                frame->source_name = strdup(file);
            }
        }

        // Set presentation hint based on frame type
        if (symbol && symbol->type == SYMBOL_TYPE_FUNCTION)
        {
            frame->presentation_hint = DAP_FRAME_PRESENTATION_NORMAL;
        }
        else
        {
            frame->presentation_hint = DAP_FRAME_PRESENTATION_LABEL;
        }
    }

    return 0;
}

/**
 * @brief Callback for setting exception breakpoints
 *
 * @param server The DAP server
 * @return int 0 on success, non-zero on failure
 */
static int on_set_exception_breakpoints(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    // Access filter data from the server's current command context
    const char **filters = server->current_command.context.exception.filters;
    size_t filter_count = server->current_command.context.exception.filter_count;
    const char **conditions = server->current_command.context.exception.conditions;
    size_t condition_count = server->current_command.context.exception.condition_count;

    // Log the received exception filters
    printf("Received %zu exception filters and %zu conditions\n", filter_count, condition_count);

    // TODO: Implement exception breakpoint handling
    return 0;
}

/**
 * @brief Command callback for setting breakpoints
 *
 * @param server DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_set_breakpoints(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    // Extract source file info from breakpoint context
    const char *source_path = server->current_command.context.breakpoint.source_path;
    int breakpoint_count = server->current_command.context.breakpoint.breakpoint_count;

    if (!source_path || breakpoint_count <= 0)
    {
        printf("Missing required breakpoint information\n");
        return -1;
    }

    // Get filename from path
    const char *source_name = strrchr(source_path, '/');
    if (source_name)
    {
        source_name++; // Skip the slash
    }
    else
    {
        source_name = source_path; // No slash found, use the whole path
    }

    printf("Setting %d breakpoints in %s\n", breakpoint_count, source_path);

    // Clear any existing breakpoints
    breakpoint_manager_clear();

    // Process each breakpoint
    for (int i = 0; i < breakpoint_count; i++)
    {
        DAPBreakpoint *bp = &server->current_command.context.breakpoint.breakpoints[i];

        bool validSymbol = false;
        uint16_t address = 0;
        uint16_t diff = 0;
        
        // Try multiple symbol tables in order of preference
        
        // 1. Try STABS (most detailed for C/mixed programs)
        if (!validSymbol && symbol_tables.symbol_table_stabs) {
            validSymbol = symbols_find_address(symbol_tables.symbol_table_stabs, 
                                              source_path, &address, &diff, bp->line);
        }
        
        // 2. Try MAP file (reliable for assembly)
        if (!validSymbol && symbol_tables.symbol_table_map) {
            validSymbol = symbols_find_address(symbol_tables.symbol_table_map, 
                                              source_path, &address, &diff, bp->line);
        }
        
        // 3. Try AOUT (last resort - function symbols)
        if (!validSymbol && symbol_tables.symbol_table_aout && str_ends_with(source_path, ".s")) {
            // For assembly files, try to find by label/function name
            // This is a fallback for when line mapping doesn't work
            validSymbol = symbols_find_address(symbol_tables.symbol_table_aout,
                                              source_path, &address, &diff, bp->line);
        }

        if (!validSymbol || diff != 0)
        {
            // If we couldn't map the line to an address, log it and continue
            char msg[256];
            const char *reason = !validSymbol ? "no symbol table entry" : "inexact match";
            snprintf(msg, sizeof(msg), 
                    "Warning: Could not map %s line %d to memory address (%s)\n", 
                    source_path, bp->line, reason);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, msg);

            bp->verified = false;
            bp->message = strdup(msg);
            continue;
        }

        bp->verified = true;

        // Add the breakpoint to the manager
        breakpoint_manager_add(
            address,           // Memory address
            BP_TYPE_USER,      // Type of breakpoint
            bp->condition,     // Optional condition expression
            bp->hit_condition, // Optional hit condition
            bp->log_message    // Optional log message
        );

        // Log the breakpoint addition
        char msg[256];
        snprintf(msg, sizeof(msg), "Added breakpoint at address %06o (line %d)\n",
                 address, bp->line);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, msg);
    }

    // Send console output about the setup
    char output_msg[256];
    snprintf(output_msg, sizeof(output_msg), "Set %d breakpoints in %s\n",
             breakpoint_count, source_name);
    dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, output_msg);

    return 0;
}

void free_symbol_table()
{
    if (symbol_tables.symbol_table_map)
    {
        symbols_free(symbol_tables.symbol_table_map);
        symbol_tables.symbol_table_map = NULL;
    }

    if (symbol_tables.symbol_table_aout)
    {
        symbols_free(symbol_tables.symbol_table_aout);
        symbol_tables.symbol_table_aout = NULL;
    }

    if (symbol_tables.symbol_table_stabs)
    {
        symbols_free(symbol_tables.symbol_table_stabs);
        symbol_tables.symbol_table_stabs = NULL;
    }
}

/**
 * @brief Initialize symbol table support for the debugger
 *
 * This function loads symbols from a specified file, trying all supported formats:
 * 1. Map file format
 * 2. a.out binary format
 * 3. STABS .s file format
 *
 * @param filename Path to the symbol file
 * @return int 0 on success, non-zero on failure
 */

int init_symbol_support(const char *filename, SymbolType symbol_type)
{
    if (!filename)
    {
        return -1;
    }

    // Allocate symbol table if it doesn't exist
    if (symbol_tables.symbol_table_map == NULL)
    {
        symbol_tables.symbol_table_map = symbols_create();
    }

    if (symbol_tables.symbol_table_aout == NULL)
    {
        symbol_tables.symbol_table_aout = symbols_create();
    }

    if (symbol_tables.symbol_table_stabs == NULL)
    {
        symbol_tables.symbol_table_stabs = symbols_create();
    }

    if (symbol_tables.symbol_table_map == NULL || symbol_tables.symbol_table_aout == NULL || symbol_tables.symbol_table_stabs == NULL)
    {
        fprintf(stderr, "Error: Failed to create symbol table\n");
        free_symbol_table();
        return -1;
    }

    // Try loading symbols from the file in different formats
    bool result = false;

    switch (symbol_type)
    {
    case SYMBOL_TYPE_MAP:
        result = symbols_load_map(symbol_tables.symbol_table_map, filename);
        break;

    case SYMBOL_TYPE_AOUT:
        result = symbols_load_aout(symbol_tables.symbol_table_aout, filename);
        break;

    case SYMBOL_TYPE_STABS:
        result = symbols_load_stabs(symbol_tables.symbol_table_stabs, filename);
        break;
    default:
        fprintf(stderr, "Error: Unsupported symbol type: %d\n", symbol_type);
        return -1;
    }

    if (result)
    {
        printf("Successfully loaded symbols from %s\n", filename);
        return 0;
    }

    return -1;
}

/**
 * @brief Handle the launch request from DAP
 *
 * This function initializes the debugger environment for the specified program:
 * 1. Sets up necessary debugger state with program and source information
 * 2. Initializes execution context and resets debugger state
 * 3. Loads symbol information if map file is provided
 * 4. Sends appropriate events to the client
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_launch_callback(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    printf("Launch command received\n");

    // Extract launch parameters from debugger state
    const char *program_path = server->debugger_state.program_path;
    const char *source_path = server->debugger_state.source_path;
    const char *map_path = server->debugger_state.map_path;
    bool stop_at_entry = server->debugger_state.stop_at_entry;
    bool no_debug = server->debugger_state.no_debug;

    // Log command line arguments if provided
    char **args = server->debugger_state.args;
    int args_count = server->debugger_state.args_count;

    if (!program_path)
    {
        printf("Error: Missing program path in debugger state\n");
        return -1;
    }

    printf("Launching program: %s\n", program_path ? program_path : "(null)");
    printf("Source path: %s\n", source_path ? source_path : "(not specified)");
    printf("Map file: %s\n", map_path ? map_path : "(not specified)");
    printf("Stop at entry: %s\n", stop_at_entry ? "yes" : "no");
    printf("No debug: %s\n", no_debug ? "yes" : "no");

    // Log command line arguments if present
    if (args && args_count > 0)
    {
        char arg_log[1024] = "Command line arguments:";
        size_t log_pos = strlen(arg_log);

        for (int i = 0; i < args_count && i < 10; i++)
        { // Limit to 10 args in log
            if (args[i])
            {
                int written = snprintf(arg_log + log_pos, sizeof(arg_log) - log_pos,
                                       " '%s'", args[i]);
                if (written > 0)
                {
                    log_pos += written;
                }
            }
        }

        if (args_count > 10)
        {
            snprintf(arg_log + log_pos, sizeof(arg_log) - log_pos, " ... (%d more)",
                     args_count - 10);
        }

        printf("%s\n", arg_log);
    }

    // Reset CPU state to appropriate values
    // In a real debugger, this would be where we would initialize the CPU
    // with the program's binary data

    // Set debugger state
    server->is_running = true;
    server->attached = true;
    server->debugger_state.has_stopped = true;
    server->debugger_state.current_thread_id = 1; // make sure we have a thread id

    server->debugger_state.source_line = 1;   // Start at line 1
    server->debugger_state.source_column = 1; // Start at column 1
    // Try to load symbols using different approaches
    bool symbols_loaded = false;

    // Load program
    if (program_path)
    {
        printf("Attempting to load program: %s\n", program_path);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                        "Loading program...\n");

        program_load(BOOT_AOUT, program_path, true);
        gPC = STARTADDR;
    }

    // Clear old symbols and source references
    free_symbol_table();
    free_source_references();
    // Load symbols !!

    if (map_path)
    {
        printf("Attempting to load symbols from map file: %s\n", map_path);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                        "Loading symbols from map file...\n");

        if (init_symbol_support(map_path, SYMBOL_TYPE_MAP) == 0)
        {
            symbols_loaded = true;

            // Send a detailed message about the symbols
            char message[256];
            snprintf(message, sizeof(message), "Successfully loaded symbols from map file: %s\n", map_path);
            dap_server_send_output_category(server, DAP_OUTPUT_IMPORTANT, message);
        }
    }

    // If we have a.out file, try to update symbols from it
    if (program_path)
    {
        printf("Attempting to load symbols from program binary: %s\n", program_path);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                        "Loading symbols from program binary...\n");

        if (init_symbol_support(program_path, SYMBOL_TYPE_AOUT) == 0)
        {
            symbols_loaded = true;

            // Send a detailed message about the symbols
            char message[256];
            snprintf(message, sizeof(message), "Successfully loaded symbols from binary: %s\n", program_path);
            dap_server_send_output_category(server, DAP_OUTPUT_IMPORTANT, message);
        }
    }

    // Check for potential STABS file (look for .s file with same base name as program)
    if (!symbols_loaded && program_path)
    {
        char stabs_path[600] = {0};

        // Get base program name without extension
        const char *program_basename = strrchr(program_path, '/');
        if (program_basename)
        {
            program_basename++; // Skip the slash
        }
        else
        {
            program_basename = program_path;
        }

        // Find extension
        const char *extension = strrchr(program_basename, '.');
        if (extension)
        {
            // Take only the base name
            size_t base_len = extension - program_basename;
            char base_name[256] = {0};
            strncpy(base_name, program_basename, base_len < 255 ? base_len : 255);

            // Create potential STABS file path (same directory, .s extension)
            char dir_path[256] = {0};
            if (program_basename > program_path)
            {
                // Copy directory part
                size_t dir_len = program_basename - program_path - 1; // -1 to exclude the slash
                strncpy(dir_path, program_path, dir_len < 255 ? dir_len : 255);
            }

            // Construct full STABS path
            if (dir_path[0])
            {
                snprintf(stabs_path, sizeof(stabs_path), "%s/%s.s", dir_path, base_name);
            }
            else
            {
                snprintf(stabs_path, sizeof(stabs_path), "%s.s", base_name);
            }

            // Try to load STABS file
            printf("Attempting to load symbols from STABS file: %s\n", stabs_path);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                            "Looking for STABS debug file...\n");

            // Check if file exists before trying to load
            FILE *f = fopen(stabs_path, "r");
            if (f)
            {
                fclose(f);

                dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                                "Found STABS file, loading symbols...\n");

                if (init_symbol_support(stabs_path, SYMBOL_TYPE_STABS) == 0)
                {
                    symbols_loaded = true;

                    // Send a detailed message about the symbols
                    char message[1024];
                    snprintf(message, sizeof(message), "Successfully loaded symbols from STABS: %s\n", stabs_path);
                    dap_server_send_output_category(server, DAP_OUTPUT_IMPORTANT, message);
                }
            }
            else
            {
                dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                                "No STABS debug file found\n");
            }
        }
    }

    // If no symbols loaded from any source, warn the user
    if (!symbols_loaded)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                        "Warning: No symbols loaded. Source level debugging may not work correctly.\n");
    }
    // Update the server's program counter from the CPU
    server->debugger_state.program_counter = gPC;

    // Create initial stack trace
    debugger_build_stack_trace(gPC, 0);

    // If we have symbols, try to map initial PC to a source line
    int line = symbols_get_line(symbol_tables.symbol_table_map, gPC);
    const char *file = symbols_get_file(symbol_tables.symbol_table_map, gPC);

    if (line > 0 && file)
    {
        server->debugger_state.source_line = line;
        // Show initial source mapping
        char message[256];
        snprintf(message, sizeof(message), "Initial PC %06o mapped to %s:%d\n",
                 gPC, file, line);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, message);
    }

    // Send process event to indicate execution started
    dap_server_send_process_event(server, program_path, 1, true, "launch");

    // Output a confirmation message to the debug console
    char message[256];
    snprintf(message, sizeof(message), "Launched program: %s\n", program_path);
    dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, message);

    // Send stopped event if stopAtEntry is true
    if (stop_at_entry)
    {
        dap_server_send_stopped_event(server, "entry", "Stopped at program entry");
        printf("Stopped at entry point\n");
        set_cpu_run_mode(CPU_PAUSED);
        set_cpu_stop_reason(STOP_REASON_ENTRY);
    }
    else
    {
        // Send thread started event
        dap_server_send_thread_event(server, "started", 1);
        set_cpu_run_mode(CPU_RUNNING);
    }

    return 0; // Return success to ensure the response is properly set
}

static int cmd_configuration_done(DAPServer *server)
{
    printf("Configuration done command received\n");

    // Send the response
    server->debugger_state.configuration_done = true;

    return 0;
}

/// @brief Handle the restart request from DAP
/// @param server The DAP server instance
/// @return 0 if successful, -1 if error
/// @details This function handles the restart request from DAP.
/// It sends a response to the client with success=true.
static int cmd_restart(DAPServer *server)
{
    printf("Restart command received\n");

    // Respond to the client with success=true

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        return -1;
    }

    // Add success status
    cJSON_AddBoolToObject(body, "success", true);

    // Send the response
    dap_server_send_response(server, DAP_CMD_RESTART, server->sequence++,
                             server->current_command.request_seq, true, body);

    // Clean up
    cJSON_Delete(body);

    // Clear breakpoints
    breakpoint_manager_clear();

    // Reset CPU state
    cpu_reset();

    // Call launch callback to restart the program
    return cmd_launch_callback(server);

    return 0;
}

/// @brief Handle the disconnect request from DAP
/// @param server The DAP server instance
/// @return 0 if successful, -1 if error
/// @details This function handles the disconnect request from DAP.
/// It sends an exited event to the client, a terminated event to the client,
/// and a response to the client.
static int cmd_disconnect(DAPServer *server)
{
    printf("Disconnect command received\n");

    dap_server_send_exited_event(server, 0);

    // Send a terminated event to the client
    dap_server_send_terminated_event(server, false);

    // Send the response
    dap_server_send_response(server, DAP_CMD_DISCONNECT, server->sequence++,
                             server->current_command.request_seq, true, NULL);

    if (server->current_command.context.disconnect.terminate_debuggee)
    {
        // Kill your process/emulator/thread safely
        set_cpu_run_mode(CPU_SHUTDOWN);
    }
    else
    {
        set_cpu_run_mode(CPU_STOPPED);
    }

    return 0;
}

/// @brief Handle the terminate request from DAP

/// @param server The DAP server instance
/// @return 0 if successful, -1 if error
/// @details This function handles the terminate request from DAP.
/// It sends a response to the client with success=true.
/// Please stop the debuggee, but don't tear down the debug session completely yet.
static int cmd_terminate(DAPServer *server)
{
    printf("Terminate command received\n");

    // Send the response
    dap_server_send_response(server, DAP_CMD_TERMINATE, server->sequence++,
                             server->current_command.request_seq, true, NULL);

    // Send an exited event to the client
    dap_server_send_exited_event(server, 0);

    // Send a terminated event to the client
    dap_server_send_terminated_event(server, false);

    // DAP Adapter should now
    // 1. Stop/kill the emulator or target process
    // 2. Free any target-specific resources (RAM, CPU, threads, memory mappings, file handles...)
    // Here we do:
    // Set the CPU run mode to paused
    set_cpu_run_mode(CPU_PAUSED);
    return 0;
}

/// @brief DAP command to set a variable
/// @param server
/// @return
static int cmd_set_variable(DAPServer *server)
{
    return 0;
}

/// @brief DAP command to read memory
/// @param server
/// @return
static int cmd_read_memory(DAPServer *server)
{
    // Extract parameters from the command context
    uint32_t memory_reference = server->current_command.context.read_memory.memory_reference;
    uint32_t offset = server->current_command.context.read_memory.offset;
    size_t byteCount = server->current_command.context.read_memory.count;

    uint32_t virtualAddress = memory_reference + offset;

    server->current_command.context.read_memory.base64_data = NULL;
    server->current_command.context.read_memory.unreadable_bytes = byteCount;

    if (byteCount == 0)
    {
        server->current_command.context.read_memory.base64_data = strdup("");
        server->current_command.context.read_memory.unreadable_bytes = 0;
        return 0;
    }

    // read memory from memory_reference + offset, count bytes
    uint8_t *data = (uint8_t *)malloc(byteCount);
    if (!data)
    {
        return 0;
    }

    memset(data, 0, byteCount);

    // Loop through the data and read each word, split the word in two so we add bytes to the data. Use ReadVirtualMemory to read the data.

    for (size_t i = 0; i < byteCount / 2; i++)
    {
        int word = ReadVirtualMemory(virtualAddress, false);
        if (word == -1)
        {
            server->current_command.context.read_memory.unreadable_bytes = byteCount - i * 2;
            break;
        }

        data[i * 2] = (uint8_t)(word >> 8);
        data[i * 2 + 1] = (uint8_t)(word & 0xFF);
        server->current_command.context.read_memory.unreadable_bytes -= 2;
        virtualAddress++;
    }

    // encode data to base64
    server->current_command.context.read_memory.base64_data = base64_encode(data, byteCount);

    // free data
    free(data);

    // return success
    return 0;
}

/// @brief DAP command to write memory
/// @param server
/// @return
static int cmd_write_memory(DAPServer *server)
{
    return 0;
}

/// @brief DAP command to retrieve source file content
/// @param server DAP server instance
/// @return 0 on success, -1 on error
static int cmd_source(DAPServer *server)
{
    if (!server) return -1;

    // NOTE: context.source is not available in current libdap API
    // This command needs to be reimplemented when libdap adds source context support
    dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                    "Error: Source command not yet implemented in current DAP library version\n");
    return -1;

    /* TODO: Reimplement when libdap adds source context
    int sourceReference = server->current_command.context.source.source_reference;

    // Load source file content
    char *content = load_source_file_by_reference(sourceReference);

    if (!content) {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                        "Error: Could not load source file\n");
        return -1;
    }

    // Store in context for response
    server->current_command.context.source.content = content;

    return 0;
    */
}

// cpu/cpu_disasm.c
void OpToStr(char *return_string, uint16_t max_len, uint16_t operand);

/// @brief DAP command to disassemble
/// @param server
/// @return
static int cmd_disassemble(DAPServer *server)
{
    uint16_t memory_reference = server->current_command.context.disassemble.memory_reference;
    int offset = server->current_command.context.disassemble.offset;                         // Offset in bytes
    int instruction_offset = server->current_command.context.disassemble.instruction_offset; // Offset in instructions (relative to the memory reference)
    int instruction_count = server->current_command.context.disassemble.instruction_count;   // Number of instructions to disassemble
    bool resolve_symbols = server->current_command.context.disassemble.resolve_symbols;      // Whether to resolve symbols

    int virtualAddress = memory_reference + offset + instruction_offset;

    // Allocate memory for the instructions
    server->current_command.context.disassemble.instructions = (DisassembleInstruction *)malloc(instruction_count * sizeof(DisassembleInstruction));
    if (!server->current_command.context.disassemble.instructions)
    {
        return -1;
    }

    // Clear the instructions
    memset(server->current_command.context.disassemble.instructions, 0, instruction_count * sizeof(DisassembleInstruction));

    // Set the actual instruction count to 0
    server->current_command.context.disassemble.actual_instruction_count = 0;

    // Loop through the instructions and disassemble each one
    for (int i = 0; i < instruction_count; i++)
    {
        // Get pointer to the instruction
        DisassembleInstruction *instruction = &server->current_command.context.disassemble.instructions[server->current_command.context.disassemble.actual_instruction_count];
        if (virtualAddress < 0)
        {
            // Might happen if the instruction offset is too large
            continue;
        }
        else
        {

            uint16_t operand = ReadVirtualMemory(virtualAddress, false);

            // Get the address of the instruction (DAP SPEC says it must be hex)
            char address_str[10];
            snprintf(address_str, sizeof(address_str), "0x%04x", virtualAddress);
            instruction->address = strdup(address_str);

            // Get the instruction

            // Disassemble the instruction
            char operand_str[50];
            OpToStr(operand_str, sizeof(operand_str), operand);

            char instruction_str[100];
            snprintf(instruction_str, sizeof(instruction_str), "%06o %s", operand, operand_str);

            instruction->instruction = strdup(instruction_str);
            instruction->symbol = NULL;
            // Get the symbol
            if (resolve_symbols)
            {
                const char *sym = get_symbol_for_address(virtualAddress);
                if (sym)
                {
                    instruction->symbol = strdup(sym);
                }
            }
        }

        // Add the instruction to the instructions array
        server->current_command.context.disassemble.actual_instruction_count++;
        virtualAddress++;
    }
}

/// @brief Initialize the DAP server
/// @param port The port to listen on
/// @return 0 if successful, -1 if error
/// @details This function initializes the DAP server.
/// It creates a new DAP server instance and registers the necessary callbacks.
/// It then starts the server and returns the result.
int ndx_server_init(int port)
{
    // Initialize DAP server
    DAPServerConfig config = {
        .transport = {
            .type = DAP_TRANSPORT_TCP,
            .config = {
                .tcp = {
                    .host = "localhost",
                    .port = port}}},
    };

    server = dap_server_create(&config);
    if (!server)
    {
        return -1;
    }

    // Hook up callbacks

    // Register launch callback
    dap_server_register_command_callback(server, DAP_CMD_LAUNCH, cmd_launch_callback);

    // Register configuration done callback
    dap_server_register_command_callback(server, DAP_CMD_CONFIGURATION_DONE, cmd_configuration_done);

    // Register restart callback
    dap_server_register_command_callback(server, DAP_CMD_RESTART, cmd_restart);

    // Disconnect request
    dap_server_register_command_callback(server, DAP_CMD_DISCONNECT, cmd_disconnect);

    // Terminate request
    dap_server_register_command_callback(server, DAP_CMD_TERMINATE, cmd_terminate);

    // Hook up commands for stopping and starting the debugger's access to the CPU
    dap_server_register_command_callback(server, DAP_WAIT_FOR_DEBUGGER, cmd_wait_for_debugger);
    dap_server_register_command_callback(server, DAP_RELEASE_DEBUGGER, cmd_release_debugger);
    dap_server_register_command_callback(server, DAP_CHECK_CPU_EVENTS, cmd_check_cpu_events);

    // Set up stepping callbacks through command callbacks only
    // Register command-specific implementations using the wrapper functions
    dap_server_register_command_callback(server, DAP_CMD_NEXT, cmd_next);
    dap_server_register_command_callback(server, DAP_CMD_STEP_IN, cmd_step_in);
    dap_server_register_command_callback(server, DAP_CMD_STEP_OUT, cmd_step_out);

    // Register continue callback
    dap_server_register_command_callback(server, DAP_CMD_CONTINUE, cmd_continue);

    // Register exception breakpoint callback
    dap_server_register_command_callback(server, DAP_CMD_SET_EXCEPTION_BREAKPOINTS, on_set_exception_breakpoints);

    // Register breakpoint callback
    dap_server_register_command_callback(server, DAP_CMD_SET_BREAKPOINTS, cmd_set_breakpoints);

    // Register stack trace callback
    dap_server_register_command_callback(server, DAP_CMD_STACK_TRACE, cmd_stack_trace);

    // Register scopes callback
    dap_server_register_command_callback(server, DAP_CMD_SCOPES, cmd_scopes);

    // Register variables callback
    dap_server_register_command_callback(server, DAP_CMD_VARIABLES, cmd_variables);

    // Register set variable callback
    dap_server_register_command_callback(server, DAP_CMD_SET_VARIABLE, cmd_set_variable);

    // Register read memory callback
    dap_server_register_command_callback(server, DAP_CMD_READ_MEMORY, cmd_read_memory);

    // Register write memory callback
    dap_server_register_command_callback(server, DAP_CMD_WRITE_MEMORY, cmd_write_memory);

    // Register disassemble callback
    dap_server_register_command_callback(server, DAP_CMD_DISASSEMBLE, cmd_disassemble);

    // Register source callback
    dap_server_register_command_callback(server, DAP_CMD_SOURCE, cmd_source);

    // Configure which capabilities are supported
    set_default_dap_capabilities(server);

    // Start server and transport layer
    int result = dap_server_start(server);
    if (result != 0)
    {
        return result;
    }

    return 0;
}

int ndx_server_stop()
{
    if (!server)
    {
        return -1;
    }

    dap_server_stop(server);
    dap_server_free(server);
    server = NULL;
    return 0;
}

void debugger_kbd_input(char c)
{

    if (c == 'q')
    {
        set_cpu_run_mode(CPU_SHUTDOWN);
    }

    // Print the current PC and run mode
    if (c == '.')
    {
        int runMode = get_cpu_run_mode();

        printf("P=%6o  RunMode=%d\n", gPC, runMode);
    }

    // Step the CPU
    if (c == ' ')
    {
        cpu_run(1);
        printf("%6o\n", gPC);
    }

    // Disassemble the instruction at the current PC
    if (c == 'd')
    {
        int runMode = get_cpu_run_mode();
        printf("P=%6o  RunMode=%d\n\n", gPC, runMode);

        int virtualAddress = gPC;
        for (int i = 0; i < 10; i++)
        {

            uint16_t operand = ReadVirtualMemory(virtualAddress, false);

            // Get the address of the instruction (DAP SPEC says it must be hex)
            printf("[%06o] ", virtualAddress);

            // Get the instruction

            // Disassemble the instruction
            char operand_str[50];
            OpToStr(operand_str, sizeof(operand_str), operand);

            char instruction_str[100];
            printf("%06o %s", operand, operand_str);

            const char *sym = get_symbol_for_address(virtualAddress);
            if (sym)
            {
                printf("    (%s)", sym);
            }

            printf("\n");

            virtualAddress++;
        }
    }
}

// Add this before the end of the #ifdef WITH_DEBUGGER section
#ifdef WITH_DEBUGGER
/**
 * @brief Find a symbol by address
 *
 * @param symtab Symbol table to search
 * @param address Memory address to look up
 * @return const char* Symbol name or NULL if not found
 */
const char *find_symbol_by_address(symbol_table_t *symtab, uint16_t address)
{
    if (!symtab)
    {
        return NULL;
    }

    const symbol_entry_t *entry = symbols_lookup_by_address(symtab, address);
    if (entry && entry->name)
    {
        return entry->name;
    }

    return NULL;
}

/**
 * @brief Helper function to find a symbol by address using the global symbol table
 *
 * @param address Memory address to look up
 * @return const char* Symbol name or NULL if not found
 */
const char *get_symbol_for_address(uint16_t address)
{
    return find_symbol_by_address(symbol_tables.symbol_table_aout, address);
}

/**
 * @brief Get source file and line for an address
 *
 * @param address Memory address to look up
 * @param line Pointer to store the line number
 * @return const char* Source filename or NULL if not found
 */
const char *get_source_location(uint16_t address, int *line)
{
    if (!symbol_tables.symbol_table_map || !line)
    {
        return NULL;
    }

    *line = symbols_get_line(symbol_tables.symbol_table_map, address);
    return symbols_get_file(symbol_tables.symbol_table_map, address);
}

/**
 * @brief Set up the default capabilities for the mock server
 *
 * This function configures which DAP capabilities our mock server
 * actually supports based on our implementation.
 *
 * @param server The DAP server instance
 * @return int The number of capabilities set
 */
int set_default_dap_capabilities(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    return dap_server_set_capabilities(server,
                                       // Core session management
                                       DAP_CAP_CONFIG_DONE_REQUEST, true,
                                       DAP_CAP_RESTART_REQUEST, true,
                                       DAP_CAP_TERMINATE_REQUEST, true,
                                       DAP_CAP_TERMINATE_DEBUGGEE, true,
                                       
                                       // Memory operations
                                       DAP_CAP_READ_MEMORY_REQUEST, true,
                                       DAP_CAP_DISASSEMBLE_REQUEST, true,
                                       
                                       // Breakpoint features
                                       DAP_CAP_LOG_POINTS, true,  // Already works!
                                       DAP_CAP_STEPPING_GRANULARITY, true,  // Line/instruction stepping
                                       DAP_CAP_INSTRUCTION_BREAKPOINTS, true,  // Assembly breakpoints
                                       
                                       // Variable inspection (removed false claims)
                                       // DAP_CAP_EVALUATE_FOR_HOVERS - not implemented
                                       // DAP_CAP_SET_VARIABLE - stub only
                                       // DAP_CAP_WRITE_MEMORY_REQUEST - stub only

                                       DAP_CAP_COUNT // End of list
    );
}
#endif // WITH_DEBUGGER

#endif // WITH_DEBUGGER

// Empty implementations when debugger is not enabled
#ifndef WITH_DEBUGGER

void start_debugger()
{
    // Do nothing when debugger is not enabled
}

int ndx_server_init(int port)
{
    (void)port;
    return -1; // Not implemented
}

int ndx_server_stop()
{
    return -1; // Not implemented
}

void debugger_kbd_input(char c)
{
    (void)c; // Unused parameter
}

#endif // !WITH_DEBUGGER
