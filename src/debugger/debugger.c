#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>
#include <stdatomic.h>

#include "debugger.h"
#include "../cpu/cpu_types.h"
#include "../cpu/cpu_protos.h"

#ifdef WITH_DEBUGGER

#include "../../external/libdap/libdap/include/dap_server.h"
#include "../../external/libdap/libdap/include/dap_server_cmds.h"
#include "../../external/libdap/libdap/include/dap_protocol.h"
#include "../../external/libsymbols/include/symbols.h"
#include "symbols_support.h"
#include "machine_types.h"
#include "machine_protos.h"

#include "ndlib_types.h"
#include "ndlib_protos.h"

#include "debugger_protos.h"

// Forward declarations for CPU breakpoint functions

// Define scope IDs
#define SCOPE_ID_LOCALS 1000
#define SCOPE_ID_REGISTERS 1001
#define SCOPE_ID_LEVELS 1002

#define SCOPE_ID_INTERNAL_REGISTERS_READ 1010
#define SCOPE_ID_INTERNAL_REGISTERS_WRITE 1011

#define SCOPE_ID_STATUS_FLAGS 1100
#define SCOPE_ID_MEM_PT 1101
#define SCOPE_ID_MEM_APT 1102

#define NUM_SCOPES 8 // Locals, Registers, Levels, Internal read, Internal write, status flags, memory PT, memory APT

// DAP server instance
DAPServer *server;

// Global symbol table

SymbolTables symbol_tables;

// Structure to hold the stack trace information
StackTrace stack_trace;

#ifdef _WIN32
#include <windows.h>
HANDLE p_debugger_thread;
#else
// Two defines for Linux, to make the compiler not complain about the WIN32 API (which is autogenerated in the proto file)

#include <stdatomic.h>
#include <pthread.h>
pthread_t p_debugger_thread;
#endif

#include "debugger_protos.h"
#include "debugger.h"

// Add atomic flag for thread termination
static atomic_bool debugger_thread_should_exit = false;

// Signal handler for the debugger thread
static void debugger_signal_handler(int sig)
{
    if (sig == SIGINT)
    {
        atomic_store(&debugger_thread_should_exit, true);
    }
}

#ifdef _WIN32
debugger_thread_win(LPVOID lpParam)
#else
void *debugger_thread(void *arg)
#endif
{
#ifdef _WIN32
    // Hook up sigint handler to terminate the server
    signal(SIGINT, debugger_signal_handler);
#else
    // Set up signal handler for this thread
    struct sigaction sa;
    sa.sa_handler = debugger_signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGINT, &sa, NULL);
#endif

    int port = 4711;
    int ret = ndx_server_init(port);
    if (ret != 0)
    {
        printf("Failed to initialize DAP server\n");
        THREAD_RETURN(0);
    }

    printf("NDX debugger listening on port %d...\n", port);
    printf("Press Ctrl+C to exit\n");

    // Run the server's message processing loop with periodic checks for exit
    while (server->is_running)
    {
        if (atomic_load(&debugger_thread_should_exit))
            break;

        if (dap_server_run(server) != 0)
        {
            fprintf(stderr, "Error: Server message loop failed.\n");
            break;
        }
        // Small sleep to prevent busy waiting
        usleep(10000); // 10ms
    }    

    // Make sure CPU exits
    set_cpu_run_mode(CPU_SHUTDOWN);

    // Stop the server and transport
    dap_server_stop(server);

    // Clean up before exiting
    dap_server_free(server);
    server = NULL;
    THREAD_RETURN(0);
}

void start_debugger()
{
    // Start the debugger thread
#ifdef _WIN32
    p_debugger_thread = CreateThread(
        NULL,                // default security attributes
        0,                   // default stack size
        debugger_thread_win, // thread function
        NULL,                // argument to thread function
        0,                   // default creation flags
        NULL);               // receive thread identifier (optional)
#else
    pthread_create(&p_debugger_thread, NULL, debugger_thread, NULL);
#endif
}

/// @brief Terminate the DAP server
/// @param exit_code
void ndx_server_terminate(int sig)
{

    // Sends a terminated event to the client and terminate the DAP server
    dap_server_terminate(server, 0);
}

/// @brief Stop the DAP server thread
void stop_debugger_thread()
{
    // Signal the thread to exit    
    atomic_store(&debugger_thread_should_exit, true);

    // Wait for the thread to finish
    if (p_debugger_thread)
    {
#ifdef _WIN32
        WaitForSingleObject(p_debugger_thread, INFINITE);
        CloseHandle(p_debugger_thread);
#else
        pthread_join(p_debugger_thread, NULL);        
#endif


        p_debugger_thread = 0;
    }
}

const char *cpuStopReasonToString(CpuStopReason r)
{
    switch (r)
    {
    case STOP_REASON_STEP:
        return "step";
    case STOP_REASON_BREAKPOINT:
        return "breakpoint";
    case STOP_REASON_EXCEPTION:
        return "exception";
    case STOP_REASON_PAUSE:
        return "pause";
    case STOP_REASON_ENTRY:
        return "entry";
    case STOP_REASON_GOTO:
        return "goto";
    case STOP_REASON_FUNCTION_BREAKPOINT:
        return "function breakpoint";
    case STOP_REASON_DATA_BREAKPOINT:
        return "data breakpoint";
    case STOP_REASON_INSTRUCTION_BREAKPOINT:
        return "instruction breakpoint";
    default:
        return "pause";
    }
}

static int cmd_wait_for_debugger(DAPServer *server)
{
    int cnt = 0;
    int max_cnt = 10000; // 10000 * 1ms = 10s
    // Tell CPU thread we want it to pause
    if (get_cpu_run_mode() == CPU_SHUTDOWN)
        return -1; // CPU is shutting down, no need to pause

    set_debugger_request_pause(true);

    // Now wait until CPU acknowledges and grants control
    while (!get_debugger_control_granted())
    {
        usleep(1000); // small sleep to avoid busy spin (1ms)
        cnt++;
        if (cnt > max_cnt)
        {
            return -1;
        }
    }

    // CPU is paused; debugger now owns control
    return 0;
}

static int cmd_release_debugger(DAPServer *server)
{
    // Release debugger's request to pause (let CPU decide to run/step)
    set_debugger_request_pause(false);

    // Notify CPU thread that debugger control is released
    set_debugger_control_granted(false);

    return 0;
}

static int cmd_check_cpu_events(DAPServer *server)
{

    CpuStopReason reason = get_cpu_stop_reason();
    if (reason != STOP_REASON_NONE)
    {
        const char *dap_reason_str = cpuStopReasonToString(reason);
        if (dap_server_send_stopped_event(server, dap_reason_str, NULL) == 0)
        {
            server->debugger_state.has_stopped = true;
            // Mesaage sent succesfully, now clear the stop reason
            set_cpu_stop_reason(STOP_REASON_NONE);
            dap_server_send_output_category(server, DAP_OUTPUT_STDOUT, dap_reason_str);
        }
    }

    return 0;
}

static void ensure_cpu_running()
{
    CPURunMode run_mode = get_cpu_run_mode();
    if ((run_mode == CPU_PAUSED) || (run_mode == CPU_BREAKPOINT))
    {
        // CPU is paused, so we need to resume it
        set_cpu_run_mode(CPU_RUNNING);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, "Switched CPU to running mode\n");
    }
}

/// @brief Find the memory address of the return address of the current stack frame.
/// @return The memory address of the return address of the current stack frame. -1 if no return address is found.
int32_t find_stack_return_address()
{
    // Check if we have any frames at all
    if (stack_trace.frame_count == 0)
    {
        // No frames, so we can't find a return address
        return -1;
    }

    // Get the return address of the previous frame
    return stack_trace.frames[stack_trace.current_frame].return_address;
}

/// @brief Update the entry point of the JPL instruction
/// @param pc Program counter of the JPL instruction
/// @param operand Operand of the JPL instruction
void debugger_update_jpl_entrypoint(uint16_t ea)
{
    if (stack_trace.frame_count == 0)
    {
        return;
    }

    // Update the entry point of the JPL instruction
    stack_trace.frames[stack_trace.current_frame].entry_point = ea;
}

/// @brief Called by the CPU before executing an instruction
/// @details This function is called by the CPU before executing an instruction.
/// It builds the stack trace and sends it to the DAP server.
void debugger_build_stack_trace(uint16_t pc, uint16_t operand)
{

    // Check if this is a JPL instruction
    bool is_jpl = ((operand & 0xF800) == 0134000);

    // Check if this is an EXIT instruction (146142)
    bool is_exit = (operand == 0146142);

    // Is this the first frame?
    if (stack_trace.frame_count == 0)
    {
        stack_trace.frame_count = 1;
        stack_trace.current_frame = 0;

        // Add the root frame to our circular buffer        
        stack_trace.frames[stack_trace.current_frame].operand = operand;
        stack_trace.frames[stack_trace.current_frame].return_address = pc;
        stack_trace.frames[stack_trace.current_frame].entry_point = pc;
        stack_trace.frames[stack_trace.current_frame].pc = pc;
    }
    

    if (is_jpl)
    {
        // For JPL, we need to create a new stack frame
        // Calculate the return address (next instruction after JPL)
        uint16_t return_address = pc + 1;


        stack_trace.current_frame = (stack_trace.current_frame + 1) % MAX_STACK_FRAMES;
        if (stack_trace.frame_count < MAX_STACK_FRAMES)
        {
            stack_trace.frame_count++;
        }


        // Add the new frame to our circular buffer
        stack_trace.frames[stack_trace.current_frame].pc = pc;
        stack_trace.frames[stack_trace.current_frame].operand = operand;
        stack_trace.frames[stack_trace.current_frame].return_address = return_address;
        stack_trace.frames[stack_trace.current_frame].entry_point = 0; // the address where JPL will jump to (will be updated when JPL is executed)      
        
        return;
    }
    else if (is_exit)
    {
        // For EXIT, we need to remove the last frame
        if (stack_trace.frame_count > 1)
        {
            // Clear the current frame
            stack_trace.frames[stack_trace.current_frame].pc =0;
            stack_trace.frames[stack_trace.current_frame].operand = 0;
            stack_trace.frames[stack_trace.current_frame].return_address = 0;
            stack_trace.frames[stack_trace.current_frame].entry_point = 0;

            // Move back one frame
            stack_trace.current_frame = (stack_trace.current_frame - 1 + MAX_STACK_FRAMES) % MAX_STACK_FRAMES;
            stack_trace.frame_count--;  
        }

        return;
    }
    else
    {
        stack_trace.frames[stack_trace.current_frame].pc = pc;
    }


}

/// @brief Step the CPU by the given step type
/// @param server The DAP server instance
/// @param step_type The type of step to take
/// @return 0 on success, -1 on failure
int step_cpu(DAPServer *server, StepType step_type)
{
    if (!server)
    {
        return -1;
    }

    uint16_t current_pc = gPC;
    uint16_t target_pc = 0;
    bool stepping_to_line = false;

    // Access the step command context
    StepCommandContext *ctx = &server->current_command.context.step;

    char log_message[256];

    // Step over - step to next line (F10)
    if (step_type == STEP_OVER)
    {

        // Implement special handling for EXIT instruction
        if (gReg->myreg_IR == 014614)
        {
            // Set a temporary breakpoint at the return address
            int return_address = find_stack_return_address();
            if (return_address < 0)
                return -1;

            breakpoint_manager_add(return_address, BP_TYPE_TEMPORARY, NULL, NULL, NULL);
            ensure_cpu_running();
            return 0;
        }

        // Implement special handling for JMP, Conditional Jumps and SKP
        if (cpu_instruction_is_jump())
        {
            // Tell breakpoint manager to step one instruction
            breakpoint_manager_step_one();
            ensure_cpu_running();
            return 0;
        }

        // If we have symbol table and want to step by line
        if (symbol_tables.symbol_table_map && ((ctx->granularity == DAP_STEP_GRANULARITY_LINE) || (ctx->granularity == DAP_STEP_GRANULARITY_STATEMENT)))
        {
            // Get the next line's address
            target_pc = symbols_get_next_line_address(symbol_tables.symbol_table_map, current_pc);

            if (target_pc != 0 && target_pc != current_pc)
            {
                stepping_to_line = true;
                snprintf(log_message, sizeof(log_message),
                         "Stepping to next line at address %06o\n", target_pc);
                dap_server_send_output(server, log_message);
            }
        }

        // Set a temporary breakpoint at the target address if we're stepping to a line
        if (stepping_to_line && target_pc != 0 && target_pc != current_pc)
        {
            snprintf(log_message, sizeof(log_message), "Setting temporary breakpoint at address %06o\n", target_pc);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_message);

            // Use the CPU's breakpoint system to set a temporary breakpoint
            // This breakpoint will be automatically removed when hit
            breakpoint_manager_add(target_pc, BP_TYPE_TEMPORARY, NULL, NULL, NULL);
        }
        else
        {
            // Tell breakpoint manager to step one instruction
            breakpoint_manager_step_one();
        }

        ensure_cpu_running();
        return 0;
    }

    // Step in - step one instruction (F11)
    if (step_type == STEP_IN)
    {
        snprintf(log_message, sizeof(log_message), "Stepping on instruction from %06o\n", current_pc);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_message);

        // Tell breakpoint manager to step one instruction
        breakpoint_manager_step_one();
        ensure_cpu_running();
        return 0;
    }

    // Step out - step to the next return address (Shift+F11)
    if (step_type == STEP_OUT)
    {
        // Step out - step to the next return address
        uint16_t return_address = find_stack_return_address();
        if (return_address != -1)
        {
            breakpoint_manager_add(return_address, BP_TYPE_TEMPORARY, NULL, NULL, NULL);
            ensure_cpu_running();
            return 0;
        }
    }

    return -1;
}

/********************************** CALLBACKS **********************************/

/**
 * @brief Step Next command handler
 *
 * Handles the 'next' command by stepping over the current line/statement
 * VS Code F10
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_next(DAPServer *server)
{
    return step_cpu(server, STEP_OVER);
}

/**
 * @brief Step In command handler
 *
 * Handles the 'stepIn' command by stepping into a function call
 * VS Code F11
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_step_in(DAPServer *server)
{
    return step_cpu(server, STEP_IN);
}

/**
 * @brief Step Out command handler
 *
 * Handles the 'stepOut' command by stepping out of the current function
 * VS Code Shift+F11
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_step_out(DAPServer *server)
{
    return step_cpu(server, STEP_OUT);
}

static int cmd_continue(DAPServer *server)
{

    CPURunMode run_mode = get_cpu_run_mode();
    if ((run_mode == CPU_PAUSED) || (run_mode == CPU_BREAKPOINT))
    {
        set_cpu_run_mode(CPU_RUNNING);
        return 0;
    }

    return 1; // Error
}

/**
 * @brief Handle DAP scopes request
 *
 * This function creates scope objects for the variables visible in the current stack frame.
 * It defines several scopes:
 * 1. Locals - Local variables
 * 2. CPU Registers - CPU register values
 * 3. Memory - Memory regions
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_scopes(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    // Extract frame_id from the command context
    int frame_id = server->current_command.context.scopes.frame_id;

    printf("Scopes request for frame ID: %d\n", frame_id);


    // Allocate memory for the scopes
    DAPScope *scopes = (DAPScope *)calloc(NUM_SCOPES, sizeof(DAPScope));
    if (!scopes)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                        "Error: Failed to allocate memory for scopes\n");
        return -1;
    }

    // Set up Locals scope
    int scope_index = 0;

    if (stack_trace.frames[stack_trace.current_frame].variables.number_of_variables > 0)
    {
        scopes[scope_index].name = strdup("Locals");        
        scopes[scope_index].variables_reference = SCOPE_ID_LOCALS;
        scopes[scope_index].named_variables = stack_trace.frames[stack_trace.current_frame].variables.number_of_variables; // Number of local variables
        scopes[scope_index].indexed_variables = 0;
        scopes[scope_index].expensive = false;
        // Source location fields are optional, set to 0/NULL
        scopes[scope_index].source_path = NULL;
        scopes[scope_index].line = 0;
        scopes[scope_index].column = 0;
        scopes[scope_index].end_line = 0;
        scopes[scope_index].end_column = 0;     
        scope_index++;
    }

    // Set up CPU Registers scope
    scopes[scope_index].name = strdup("CPU Registers");
    scopes[scope_index].variables_reference = SCOPE_ID_REGISTERS;
    scopes[scope_index].named_variables = 9; // STS, D, P, B, L, A, T, X + EA
    scopes[scope_index].indexed_variables = 0;
    scopes[scope_index].expensive = false;
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;


    // Set up Levels registers
    scope_index++;
    scopes[scope_index].name = strdup("Interrupt levels");
    scopes[scope_index].variables_reference = SCOPE_ID_LEVELS;
    scopes[scope_index].named_variables = 0; // 16 levels + PIL/PVL
    scopes[scope_index].indexed_variables = 0;
    scopes[scope_index].expensive = false;
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;

    // Set up Internal Registers - Read scope
    scope_index++;
    scopes[scope_index].name = strdup("Internal Registers - Read");
    scopes[scope_index].variables_reference = SCOPE_ID_INTERNAL_REGISTERS_READ;
    scopes[scope_index].named_variables = 1; // 13 internal register
    scopes[scope_index].indexed_variables = 0;
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;

    // Set up Internal Registers - Write scope
    scope_index++;
    scopes[scope_index].name = strdup("Internal Registers - Write");
    scopes[scope_index].variables_reference = SCOPE_ID_INTERNAL_REGISTERS_WRITE;
    scopes[scope_index].named_variables = 10; // num internal registers
    scopes[scope_index].indexed_variables = 0;
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;


    // Set up Memory scope
    scope_index++;
    scopes[scope_index].name = strdup("Memory");
    scopes[scope_index].variables_reference = SCOPE_ID_MEM_PT;
    scopes[scope_index].named_variables = 3; // Number of memory regions
    scopes[scope_index].indexed_variables = 0;
    scopes[scope_index].expensive = true; // Memory access is expensive
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;

    // Store the scopes in the command context for the DAP server to use
    server->current_command.context.scopes.scopes = scopes;
    server->current_command.context.scopes.scope_count = NUM_SCOPES;

    return 0;
}

/**
 * @brief Helper function to add a variable to the server's variable array
 *
 * @param server The DAP server instance
 * @param name Variable name
 * @param value Variable value
 * @param type Variable type
 * @param variables_reference Reference for child variables (0 for leaf variables)
 * @param memory_reference Optional memory reference
 * @param kind Enum of variable kind (property, method, etc.)
 * @param attributes Enum of attributes
 * @return DAPVariable* Pointer to the newly added variable or NULL on failure
 */
static DAPVariable *add_variable_to_array(
    DAPServer *server,
    const char *name,
    const char *value,
    const char *type,
    const char *memory_reference,

    int variables_reference,    
    DAPVariableKind kind,
    DAPVariableAttributes attributes)
{
    if (!server || !name || !value)
    {
        return NULL;
    }

    // Increase the count and reallocate the array
    server->current_command.context.variables.variable_count++;
    server->current_command.context.variables.variable_array = realloc(
        server->current_command.context.variables.variable_array,
        server->current_command.context.variables.variable_count * sizeof(DAPVariable));

    if (!server->current_command.context.variables.variable_array)
    {
        server->current_command.context.variables.variable_count--;
        return NULL;
    }

    // Get a pointer to the newly added variable
    DAPVariable *var = &server->current_command.context.variables.variable_array[server->current_command.context.variables.variable_count - 1];

    // Initialize the variable with the provided values
    var->name = name ? strdup(name) : NULL;
    var->value = value ? strdup(value) : NULL;
    var->type = type ? strdup(type) : NULL;
    var->memory_reference = memory_reference ? strdup(memory_reference) : NULL;
    var->variables_reference = variables_reference;
    var->named_variables = 0;
    var->indexed_variables = 0;
    var->evaluate_name = NULL;
    
    
    var->presentation_hint.kind = kind;    
    var->presentation_hint.attributes = attributes;
    var->presentation_hint.visibility = DAP_VARIABLE_VISIBILITY_NONE;

    return var;
}

/**
 * @brief Add local variables to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_local_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
  

    // No local variables in this example, but in a real implementation
    // this would add variables from the current stack frame

    // Property kind for all variables
    const char *property_kind = "property";
    const char *no_attributes[] = {NULL};

    // Example dummy variable
    add_variable_to_array(
        server,
        "dummy",       // name
        "0",           // value
        "integer",     // type
        0,             // variablesReference
        0,             // memoryReference (no memory reference for locals)
        DAP_VARIABLE_KIND_PROPERTY, // kind
        DAP_VARIABLE_ATTR_NONE       // attributes
    );
}


static void add_level_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    
    char value_str[100];

    
    // ADD PIL
    snprintf(value_str, sizeof(value_str), "%06o", gPIL);
    add_variable_to_array(
        server,
        "PIL",       // name
        value_str,           // value
        "integer",     // type
        0,             // variablesReference
        0,             // memoryReference (no memory reference for locals)
        DAP_VARIABLE_KIND_PROPERTY, // kind
        DAP_VARIABLE_ATTR_NONE       // attributes
    );

    // ADD PVL
    snprintf(value_str, sizeof(value_str), "%06o", gPVL);
    add_variable_to_array(
        server,
        "PVL",       // name
        value_str,           // value
        "integer",     // type
        0,             // variablesReference
        0,             // memoryReference (no memory reference for locals)
        DAP_VARIABLE_KIND_PROPERTY, // kind
        DAP_VARIABLE_ATTR_NONE       // attributes
    );

    for (int i = 0; i < 16; i++)
    {
        ushort rP = gReg->reg[i][_P];
        ushort rPCR = gReg->reg_PCR[i];
        ushort pt=0, apt=0;

        // decode PCR
        ushort ring = rPCR & 0x03;
        if (rPCR & (1<<2))
        {
            // Sixteen page table mode
            pt = (rPCR >>11) & 0x0F;
            apt = (rPCR >>7) & 0x0F;
        }
        else 
        {
            // Four page table mode
            pt = (rPCR >>9) & 0x03;
            apt = (rPCR >>7) & 0x03;

        }
        ushort priority = (rPCR >> 2) & 0x07;
        char value_str[100];
        sprintf(value_str, "Ring[%d] PT[%d] APT[%d] P[%06d]", ring, pt, apt, rP);

        char name[20];
        sprintf(name, "Level %d", i);

        char memory_reference[100];
        sprintf(memory_reference, "0x%04x", rP);

        add_variable_to_array(
            server,
            name,                        // name
            value_str,                   // value
            "integer",                   // type
            memory_reference,            // memoryReference 
            0,                           // variablesReference        
            DAP_VARIABLE_KIND_DATA,      // kind
            DAP_VARIABLE_ATTR_NONE   // attributes
        );
    }
  
}

/**
 * @brief Add CPU register variables to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_register_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    snprintf(info_message, info_message_size,
             "Loading CPU registers\n");

    // Property kind with no attributes
    const char *property_kind = "property";

    server->current_command.context.variables.variable_count = 0;
    

    // Register formatting
    char value_str[32];
    char value_str_hex[32];

    // Add the ST register (Status register)
    snprintf(value_str, sizeof(value_str), "%06o", gSTSr);
    DAPVariable *var = add_variable_to_array(
        server,
        "STS",                       // name
        value_str,                   // value
        //"bitmap",                    // type
        "integer",
        NULL,                        // memoryReference 
        SCOPE_ID_STATUS_FLAGS,       // variablesReference        
        DAP_VARIABLE_KIND_DATA,      // kind
        DAP_VARIABLE_ATTR_NONE   // attributes
    );


    // Add the D register (Data register)
    snprintf(value_str, sizeof(value_str), "%06o", gD);
    snprintf(value_str_hex, sizeof(value_str_hex), "0x%04x", gD);
    add_variable_to_array(
        server,
        "D",                         // name
        value_str,                   // value
        "integer",                   // type        
        value_str_hex,               // memoryReference 
        0,                           // variablesReference
        DAP_VARIABLE_KIND_DATA,      // kind
        DAP_VARIABLE_ATTR_NONE       // attributes
    );

    // Add the P register (Program Counter)
    snprintf(value_str, sizeof(value_str), "%06o", gPC);
    snprintf(value_str_hex, sizeof(value_str_hex), "0x%04x", gPC);
    add_variable_to_array(
        server,
        "P",                          // name
        value_str,                    // value
        "integer",                    // type
        value_str,                // memoryReference 
        0,                            // variablesReference
        DAP_VARIABLE_KIND_DATA,       // kind
        DAP_VARIABLE_ATTR_NONE       // attributes
    );
 
    // Add the B register (B register)
    snprintf(value_str, sizeof(value_str), "%06o", gB);
    snprintf(value_str_hex, sizeof(value_str_hex), "0x%04x", gB);
    add_variable_to_array(
        server,
        "B",                         // name
        value_str,                   // value
        "integer",                   // type
        value_str_hex,               // memoryReference 
        0,                           // variablesReference
        DAP_VARIABLE_KIND_DATA,      // kind
        DAP_VARIABLE_ATTR_NONE       // attributes
    );

    // Add the L register (Link register)
    snprintf(value_str, sizeof(value_str), "%06o", gL);
    snprintf(value_str_hex, sizeof(value_str_hex), "0x%04x", gL);
    add_variable_to_array(
        server,
        "L",                         // name
        value_str,                   // value
        "integer",                   // type
        value_str_hex,               // memoryReference 
        0,                           // variablesReference
        DAP_VARIABLE_KIND_DATA,      // kind
        DAP_VARIABLE_ATTR_NONE       // attributes
    );

    // Add the A register (Accumulator)
    snprintf(value_str, sizeof(value_str), "%06o", gA);
    snprintf(value_str_hex, sizeof(value_str_hex), "0x%04x", gA);
    add_variable_to_array(
        server,
        "A",                         // name
        value_str,                   // value
        "integer",                   // type
        value_str_hex,               // memoryReference 
        0,                           // variablesReference
        DAP_VARIABLE_KIND_DATA,      // kind
        DAP_VARIABLE_ATTR_NONE       // attributes
    );

    // Add the T register (T register)
    snprintf(value_str, sizeof(value_str), "%06o", gT);
    snprintf(value_str_hex, sizeof(value_str_hex), "0x%04x", gT);
    add_variable_to_array(
        server,
        "T",                         // name
        value_str,                   // value
        "integer",                   // type
        value_str_hex,               // memoryReference 
        0,                           // variablesReference
        DAP_VARIABLE_KIND_DATA,      // kind
        DAP_VARIABLE_ATTR_NONE       // attributes
    );

    // Add the X register (Index register)
    snprintf(value_str, sizeof(value_str), "%06o", gX);
    snprintf(value_str_hex, sizeof(value_str_hex), "0x%04x", gX);
    add_variable_to_array(
        server,
        "X",                         // name
        value_str,                   // value
        "integer",                   // type        
        value_str_hex,               // memoryReference 
        0,                           // variablesReference
        DAP_VARIABLE_KIND_DATA,      // kind
        DAP_VARIABLE_ATTR_NONE       // attributes
    );


    // Add the Effective address register
    snprintf(value_str, sizeof(value_str), "%06o", gEA);
    snprintf(value_str_hex, sizeof(value_str_hex), "0x%04x", gEA);
    add_variable_to_array(
        server,
        "EA",                         // name
        value_str,                   // value
        "integer",                   // type        
        value_str_hex,               // memoryReference 
        0,                           // variablesReference
        DAP_VARIABLE_KIND_DATA,      // kind
        DAP_VARIABLE_ATTR_NONE       // attributes
    );


}

/**
 * @brief Add internal CPU register variables to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_internal_registers_read_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    snprintf(info_message, info_message_size,
             "Loading internal CPU registers\n");

    // Property kind with readonly attribute
    const char *property_kind = "property";
    const char *readonly_attrs[] = {"readOnly"};

    server->current_command.context.variables.variable_count = 0;

    // Register formatting
    char value_str[32];

    // Define the internal registers with their addresses
    struct
    {
        const char *name;
        uint16_t *reg_ptr;
        const char *type;
    } internal_regs[] = {        
        {"PANS", &gReg->reg_PANS, "octal"}, // Panel status
        {"OPR", &gReg->reg_OPR, "octal"},   // Operator register        
        {"PGS", &gReg->reg_PGS, "octal"},   // Paging status register
        {"PVL", &gReg->reg_PVL, "octal"},   // Page violation limit register
        {"IIC", &gReg->reg_IIC, "octal"},   // Internal interrupt code register
        {"IID", &gReg->reg_IID, "octal"},   // Internal interrupt detect register
        {"PID", &gReg->reg_PID, "octal"},   // Priority interrupt detect register
        {"PIE", &gReg->reg_PIE, "octal"},   // Priority interrupt enable register
        {"CSR", &gReg->reg_CSR, "octal"},   // Control store register                
        {"ALD", &gReg->reg_ALD, "octal"},   // Auto-load descriptor register        
        {"PES", &gReg->reg_PES, "octal"},   // Page error status register
        {"PGC", &gReg->reg_PGC, "octal"},   // Paging Control Register
        {"PEA", &gReg->reg_PEA, "octal"},   // Page error address register        
    };

    const int num_regs = sizeof(internal_regs) / sizeof(internal_regs[0]);

    // Add each internal register to the variable array
    for (int i = 0; i < num_regs; i++)
    {
        // Format the register value in octal
        snprintf(value_str, sizeof(value_str), "%06o", *(internal_regs[i].reg_ptr));

        // Add the register to the variable array
        add_variable_to_array(
            server,
            internal_regs[i].name,                              // name
            value_str,                                          // value
            internal_regs[i].type,                              // type
            NULL,                                                // memoryReference - safely truncate to 32-bit if needed
            0,                                                  // variablesReference (no children)                        
            DAP_VARIABLE_KIND_DATA,                             // kind
            DAP_VARIABLE_ATTR_NONE                             // attributes
        );
    }
}



/**
 * @brief Add internal CPU register variables to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_internal_registers_write_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    snprintf(info_message, info_message_size,
             "Loading internal CPU registers\n");

    // Property kind with readonly attribute
    const char *property_kind = "property";    

    server->current_command.context.variables.variable_count = 0;

    // Register formatting
    char value_str[32];

    // Define the internal registers with their addresses
    struct
    {
        const char *name;
        uint16_t *reg_ptr;
        const char *type;
    } internal_regs[] = {
        {"PANC", &gReg->reg_PANC, "octal"}, // Panel control        
        {"LMP", &gReg->reg_LMP, "octal"},   // Panel data display buffer register
        {"PCR", &gReg->reg_PCR[gPIL], "octal"},   // Paging Control Register 
        {"IIE", &gReg->reg_IIE, "octal"},   // Internal interrupt enable register
        {"PID", &gReg->reg_PID, "octal"},   // Priority interrupt detect register
        {"PIE", &gReg->reg_PIE, "octal"},   // Priority interrupt enable register
        {"CCL", &gReg->reg_CCL, "octal"},   // Cache clear register
        {"LCIL", &gReg->reg_LCIL, "octal"}, // Lower cache inhibit limit register
        {"UCIL", &gReg->reg_UCIL, "octal"}, // Upper cache inhibit limit register
        {"ECCR", &gReg->reg_ECCR, "octal"}, // Error correction control register
    };

    const int num_regs = sizeof(internal_regs) / sizeof(internal_regs[0]);

    // Add each internal register to the variable array
    for (int i = 0; i < num_regs; i++)
    {
        // Format the register value in octal
        snprintf(value_str, sizeof(value_str), "%06o", *(internal_regs[i].reg_ptr));

        // Add the register to the variable array
        add_variable_to_array(
            server,
            internal_regs[i].name,                              // name
            value_str,                                          // value
            internal_regs[i].type,                              // type
            NULL,                                               // memoryReference - safely truncate to 32-bit if needed
            0,                                                  // variablesReference (no children)
            DAP_VARIABLE_KIND_DATA,                             // kind
            DAP_VARIABLE_ATTR_NONE                             // attributes
        );
    }
}
/**
 * @brief Add status flags from the STS register to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_status_flag_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    snprintf(info_message, info_message_size,
             "Loading CPU status flags\n");

    // Property kind with readonly attribute
    const char *property_kind = "property";
    const char *readonly_attrs[] = {"readOnly"};
    
    server->current_command.context.variables.variable_count = 0;

    // Status flag definitions with bit positions
    struct
    {
        const char *name;
        int bit_pos;        
    } status_flags[] = {
        {"P", 0}, // Page Table Mode
        {"T", 1}, // Rounging flag for floating point operations
        {"K", 2}, // One bit accumulato
        {"Z", 3}, // Error flag
        {"Q", 4}, // Dynamic overflow flag
        {"O", 5}, // Overflow flag
        {"C", 6}, // Carry flag
        {"M", 7}, // Multishift flag
        {"PIL", 8}, // Program level
        {"N100", 12}, // N100 flag (always 1)
        {"SEXI", 13}, // Extended flag
        {"PONI", 14}, // Memory management on flag
        {"IONI", 15}}; // Interrupt system on flag

    const int num_flags = sizeof(status_flags) / sizeof(status_flags[0]);

    // Get the current STS register value
    uint16_t sts_value = gSTSr;

    // Add each flag to the variable array
    for (int i = 0; i < num_flags; i++)
    {
        // Get the bit value (special handling for PL which is 4 bits)
        bool value;
        char value_str[32];

        if (strcmp(status_flags[i].name, "PIL") == 0)
        {
            // Extract 4-bit PL field
            int pl_value = (sts_value >> 8) & 0x0F;
            snprintf(value_str, sizeof(value_str), "%d", pl_value);
        }
        else
        {
            // Extract 1-bit flags
            value = (sts_value >> status_flags[i].bit_pos) & 0x01;
            snprintf(value_str, sizeof(value_str), "%d", value);
        }

        // Create a display name with description
        char display_name[64];
        snprintf(display_name, sizeof(display_name), "%s",
                 status_flags[i].name);

        // Add the flag to the variable array
        add_variable_to_array(
            server,
            display_name,                                                    // name with description
            value_str,                                                       // value (true/false or numeric for PL)
            strcmp(status_flags[i].name, "PIL") == 0 ? "integer" : "boolean", // type            
            NULL,                                                             // memoryReference
            0,                                                               // variablesReference (no children)
            DAP_VARIABLE_KIND_PROPERTY,                                      // kind
            DAP_VARIABLE_ATTR_NONE                                          // attributes
        );
    }
}

/**
 * @brief Add memory regions to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_memory_region_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    snprintf(info_message, info_message_size,
             "Loading memory regions (Code section, Data section, etc.)\n");

    // Property kind with readonly attribute
    const char *property_kind = "property";
    const char *no_attributes[] = {NULL};

    // Add memory regions - these are examples and should be adjusted based on
    // the actual memory layout of the ND-100 system

    // Code section - an example region where program code resides
    add_variable_to_array(
        server,
        "Memory (Code - PT)", // name
        "000000-077777",      // value
        "memory",             // type
        "000000-077777",      // memoryReference
        SCOPE_ID_MEM_PT,      // variablesReference        
        DAP_VARIABLE_KIND_PROPERTY,        // kind
        DAP_VARIABLE_ATTR_NONE            // attributes
    );

    // Data section - an example region where data resides
    add_variable_to_array(
        server,
        "Memory (DATA - APT)", // name
        "000000-077777",       // value
        "memory",              // type
        "000000-077777",       // memoryReference
        SCOPE_ID_MEM_APT,      // variablesReference        
        DAP_VARIABLE_KIND_PROPERTY,        // kind
        DAP_VARIABLE_ATTR_NONE            // attributes
    );
}

/**
 * @brief Handle DAP variables request
 *
 * This function provides variables for the requested container (scope).
 * It creates variables based on CPU state, memory content, etc.
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_variables(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    // Extract variables reference from the command context
    int variables_reference = server->current_command.context.variables.variables_reference;

    //printf("Variables request for reference: %d\n", variables_reference);

    // Buffer for informational messages
    char info_message[256] = {0};

    // Reset variable array count
    server->current_command.context.variables.variable_count = 0;
    server->current_command.context.variables.variable_array = NULL;

    // Handle different variable reference types
    switch (variables_reference)
    {
    case SCOPE_ID_LOCALS:
    {
        if (stack_trace.frames[stack_trace.current_frame].variables.number_of_variables > 0)
        {
            // Use our helper function for local variables
            add_local_variables(server, info_message, sizeof(info_message));
        }
        break;
    }

    case SCOPE_ID_REGISTERS:
    {
        // Use our helper function for register variables
        add_register_variables(server, info_message, sizeof(info_message));
        break;
    }

    case SCOPE_ID_LEVELS:
    {
        // Use our helper function for level variables
        add_level_variables(server, info_message, sizeof(info_message));
        break;
    }
    case SCOPE_ID_INTERNAL_REGISTERS_READ:
    {
        // Use our helper function for internal registers variables
        add_internal_registers_read_variables(server, info_message, sizeof(info_message));
        break;
    }
    case SCOPE_ID_INTERNAL_REGISTERS_WRITE:
    {
        // Use our helper function for internal registers variables
        add_internal_registers_write_variables(server, info_message, sizeof(info_message));
        break;
    }


    case SCOPE_ID_STATUS_FLAGS:
    {
        // Use our helper function for status flag variables
        add_status_flag_variables(server, info_message, sizeof(info_message));
        break;
    }

    case SCOPE_ID_MEM_PT:
    { // TODO: Make sure we read through PT
        // Use our helper function for memory region variables
        add_memory_region_variables(server, info_message, sizeof(info_message));
        break;
    }

    case SCOPE_ID_MEM_APT:
    { // TODO: Force PT to be APT
        // Use our helper function for memory region variables
        add_memory_region_variables(server, info_message, sizeof(info_message));
        break;
    }

    default:
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, "Unknown variable reference\n");
        break;
    }

    // Output info message if we have one
    if (info_message[0] != '\0')
    {
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, info_message);
    }

    // The variables will be used by handle_variables and converted to JSON
    // We don't need to clean up here, as the caller (handle_variables) will handle it
    // This is intentional to allow the response to be sent before freeing the memory

    return 0;
}

/// @brief Update a DAP response stack frame with the given memory reference
/// @param server DAP server instance
/// @param frame_index Index of the frame in the stack trace
/// @param frame_id Unique ID of the frame
/// @param memory_reference Memory reference of the frame
/// @param entry_point Entry point of the frame
/// @return 0 on success, -1 on failure
void update_stack_frame(DAPServer *server, int frame_index, int frame_id, uint16_t memory_reference, uint16_t entry_point)
{
    // Initialize the frame
    DAPStackFrame *frame = &server->current_command.context.stack_trace.frames[frame_index];
    frame->id = frame_id;
    frame->name = NULL;
    frame->source_path = NULL;
    frame->source_name = NULL;
    frame->line = 0;
    frame->column = 0;
    frame->end_line = 0;
    frame->end_column = 0;
    frame->can_restart = false;
    frame-> instruction_pointer_reference= -1; // -1 means no instruction pointer reference
    frame->module_id = NULL;
    frame->presentation_hint = DAP_FRAME_PRESENTATION_NORMAL;

    // Try to get symbol information if we have a symbol table
    // Get source location information
    int line = symbols_get_line(symbol_tables.symbol_table_map, memory_reference);
    const char *file = symbols_get_file(symbol_tables.symbol_table_map, memory_reference);
    const symbol_entry_t *symbol = symbols_lookup_by_address(symbol_tables.symbol_table_aout, entry_point);

    if (line > 0 && file)
    {
        // We found source information
        frame->line = line;
        frame->source_path = strdup(file);

        // Extract source name from path
        const char *name = strrchr(file, '/');
        if (name)
        {
            frame->source_name = strdup(name + 1);
        }
        else
        {
            frame->source_name = strdup(file);
        }

        // Create a frame name from the symbol or PC

        char frame_name[256];

        // If we have a symbol, use it to create a frame name
        if (symbol && symbol->name)
        {
            snprintf(frame_name, sizeof(frame_name), "%s at %06o", symbol->name, memory_reference);
        }
        else
        {
            // No symbol, use PC as frame name
            if (symbol && symbol->name)
            {
                snprintf(frame_name, sizeof(frame_name), "%s at %06o", symbol->name, memory_reference);
            }
            else
            {
                snprintf(frame_name, sizeof(frame_name), "frame at %06o", memory_reference);
            }            
        }
        
        frame->name = strdup(frame_name);

        // Log the source mapping
        char log_msg[256];
        snprintf(log_msg, sizeof(log_msg), "PC %06o mapped to %s:%d\n",
                 memory_reference, file, line);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_msg);
    }
    else
    {
        // No source information found, use PC as frame name
        char frame_name[256];
        snprintf(frame_name, sizeof(frame_name), "frame at %06o", memory_reference);
        frame->name = strdup(frame_name);
    }

    // Set instruction pointer reference (Enables disassembly of the current instruction)
    frame->instruction_pointer_reference = memory_reference; 
}

/**
 * @brief Handle DAP stackTrace request
 *
 * This function creates a stack trace response with the current call stack,
 * including source file locations and line numbers. In this implementation,
 * we create at least one stack frame for the current PC location.
 *
 * @param server The DAP server instance
 * @return int 0 on success, -1 on failure
 */
static int cmd_stack_trace(DAPServer *server)
{
    if (!server)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                      "Error: Invalid server instance\n");
        return -1;
    }

    // Validate stack trace availability
    if (stack_trace.frame_count == 0)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                      "No stack trace available\n");
        return -1;
    }

    // Extract and validate request parameters
    int stack_levels = server->current_command.context.stack_trace.levels;
    int stack_start_frame = server->current_command.context.stack_trace.start_frame;
    int frame_count = stack_trace.frame_count;

    // Validate input parameters
    if (stack_levels <= 0)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                      "Error: Invalid stack levels requested\n");
        return -1;
    }

    if (stack_start_frame < 0)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                      "Error: Invalid start frame requested\n");
        return -1;
    }

    // Calculate number of frames to return
    int frames_to_return = stack_levels;
    if (frames_to_return > (frame_count - stack_start_frame))
    {
        frames_to_return = frame_count - stack_start_frame;
    }

    // If no frames to return after calculations, return empty result
    if (frames_to_return <= 0)
    {
        server->current_command.context.stack_trace.frame_count = 0;
        server->current_command.context.stack_trace.total_frames = frame_count;
        server->current_command.context.stack_trace.frames = NULL;
        return 0;
    }

    // Allocate memory for the stack frames
    server->current_command.context.stack_trace.frame_count = frames_to_return;
    server->current_command.context.stack_trace.total_frames = frame_count;
    server->current_command.context.stack_trace.frames = malloc(sizeof(DAPStackFrame) * frames_to_return);

    // Check for allocation failure
    if (!server->current_command.context.stack_trace.frames)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                      "Error: Failed to allocate memory for stack frames\n");
        return -1;
    }

    // Fill in the stack frames in reverse order (most recent first)
    for (int i = 0; i < frames_to_return; i++)
    {
        // Calculate frame index - we want to go from newest to oldest
        // current_frame points to the newest frame, so we start there and go backwards
        int frame_idx = (stack_trace.current_frame - i + MAX_STACK_FRAMES) % MAX_STACK_FRAMES;

        // For the currrent frame, update PC
        if (frame_idx == stack_trace.current_frame)
        {
            stack_trace.frames[frame_idx].pc = gPC;
        }

        uint16_t memory_reference = stack_trace.frames[frame_idx].pc;
        uint16_t entry_point = stack_trace.frames[frame_idx].entry_point;

        // Update frame with enhanced information
        DAPStackFrame *frame = &server->current_command.context.stack_trace.frames[i];
        frame->id = frame_idx;
        frame->name = NULL;
        frame->source_path = NULL;
        frame->source_name = NULL;
        frame->line = 0;
        frame->column = 0;
        frame->end_line = 0;
        frame->end_column = 0;
        frame->can_restart = false;
        frame->instruction_pointer_reference = memory_reference;
        frame->module_id = NULL;
        frame->presentation_hint = DAP_FRAME_PRESENTATION_NORMAL;


        //symbols_dump_all(symbol_tables.symbol_table_aout);

        // Try to get symbol information
        const symbol_entry_t *symbol = symbols_lookup_by_address(symbol_tables.symbol_table_aout, entry_point);
        if (symbol && symbol->name)
        {
            frame->name = strdup(symbol->name);
            frame->valid_symbol = true;
            frame->symbol_entry_point = entry_point;                                
        }
        else
        {
            frame->name = strdup("<unknown>");
            frame->valid_symbol = false;
        }


        /*
        for (int i = 0; i < symbol_tables.symbol_table_aout->count; i++)
        {
            const symbol_entry_t *symbol = &symbol_tables.symbol_table_aout->entries[i];
            if (symbol->address == entry_point)
            {
                printf("Symbol found: %s at %06o\n", symbol->name, symbol->address);
            }
        }
        */

        // Get source location information
        int line = symbols_get_line(symbol_tables.symbol_table_map, memory_reference);
        const char *file = symbols_get_file(symbol_tables.symbol_table_map, memory_reference);

        if (line > 0 && file)
        {
            // We found source information
            frame->line = line;
            frame->source_path = strdup(file);

            // Extract source name from path
            const char *name = strrchr(file, '/');
            if (name)
            {
                frame->source_name = strdup(name + 1);
            }
            else
            {
                frame->source_name = strdup(file);
            }

            

        }
      

        // Set presentation hint based on frame type
        if (symbol && symbol->type == SYMBOL_TYPE_FUNCTION)
        {
            frame->presentation_hint = DAP_FRAME_PRESENTATION_NORMAL;
        }
        else
        {
            frame->presentation_hint = DAP_FRAME_PRESENTATION_LABEL;
        }
    }

    return 0;
}

/**
 * @brief Callback for setting exception breakpoints
 *
 * @param server The DAP server
 * @return int 0 on success, non-zero on failure
 */
static int on_set_exception_breakpoints(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    // Access filter data from the server's current command context
    const char **filters = server->current_command.context.exception.filters;
    size_t filter_count = server->current_command.context.exception.filter_count;
    const char **conditions = server->current_command.context.exception.conditions;
    size_t condition_count = server->current_command.context.exception.condition_count;

    // Log the received exception filters
    printf("Received %zu exception filters and %zu conditions\n", filter_count, condition_count);

    // TODO: Implement exception breakpoint handling
    return 0;
}

/**
 * @brief Command callback for setting breakpoints
 *
 * @param server DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_set_breakpoints(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    // Extract source file info from breakpoint context
    const char *source_path = server->current_command.context.breakpoint.source_path;
    int breakpoint_count = server->current_command.context.breakpoint.breakpoint_count;

    if (!source_path || breakpoint_count <= 0)
    {
        printf("Missing required breakpoint information\n");
        return -1;
    }

    // Get filename from path
    const char *source_name = strrchr(source_path, '/');
    if (source_name)
    {
        source_name++; // Skip the slash
    }
    else
    {
        source_name = source_path; // No slash found, use the whole path
    }

    printf("Setting %d breakpoints in %s\n", breakpoint_count, source_path);

    // Clear any existing breakpoints
    breakpoint_manager_clear();

    // Process each breakpoint
    for (int i = 0; i < breakpoint_count; i++)
    {
        DAPBreakpoint *bp = &server->current_command.context.breakpoint.breakpoints[i];

        bool validSymbol = false;
        // Try to get the a valid memory address for this line number
        uint16_t address = 0;
        uint16_t diff = 0;
        if (symbol_tables.symbol_table_map)
        {
            // Get the address for this line in the source file
            validSymbol = symbols_find_address(symbol_tables.symbol_table_map, source_path, &address,&diff, bp->line);
        }

        if ((!validSymbol) || (diff != 0))
        {
            // If we couldn't map the line to an address, log it and continue

            char msg[256];
            snprintf(msg, sizeof(msg), "Warning: Could not map line %d to memory address - missing N_SO for %s\n", bp->line, source_path);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, msg);

            bp->verified = false;
            bp->message = strdup(msg);
            continue;
        }

        bp->verified = true;

        // Add the breakpoint to the manager
        breakpoint_manager_add(
            address,           // Memory address
            BP_TYPE_USER,      // Type of breakpoint
            bp->condition,     // Optional condition expression
            bp->hit_condition, // Optional hit condition
            bp->log_message    // Optional log message
        );

        // Log the breakpoint addition
        char msg[256];
        snprintf(msg, sizeof(msg), "Added breakpoint at address %06o (line %d)\n",
                 address, bp->line);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, msg);
    }

    // Send console output about the setup
    char output_msg[256];
    snprintf(output_msg, sizeof(output_msg), "Set %d breakpoints in %s\n",
             breakpoint_count, source_name);
    dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, output_msg);

    return 0;
}

void free_symbol_table()
{
    if (symbol_tables.symbol_table_map)
    {
        symbols_free(symbol_tables.symbol_table_map);
        symbol_tables.symbol_table_map = NULL;
    }

    if (symbol_tables.symbol_table_aout)
    {
        symbols_free(symbol_tables.symbol_table_aout);
        symbol_tables.symbol_table_aout = NULL;
    }

    if (symbol_tables.symbol_table_stabs)
    {
        symbols_free(symbol_tables.symbol_table_stabs);
        symbol_tables.symbol_table_stabs = NULL;
    }
}

/**
 * @brief Initialize symbol table support for the debugger
 *
 * This function loads symbols from a specified file, trying all supported formats:
 * 1. Map file format
 * 2. a.out binary format
 * 3. STABS .s file format
 *
 * @param filename Path to the symbol file
 * @return int 0 on success, non-zero on failure
 */

int init_symbol_support(const char *filename, SymbolType symbol_type)
{
    if (!filename)
    {
        return -1;
    }

    // Allocate symbol table if it doesn't exist
    if (symbol_tables.symbol_table_map == NULL)
    {
        symbol_tables.symbol_table_map = symbols_create();
    }

    if (symbol_tables.symbol_table_aout == NULL)
    {
        symbol_tables.symbol_table_aout = symbols_create();
    }

    if (symbol_tables.symbol_table_stabs == NULL)
    {
        symbol_tables.symbol_table_stabs = symbols_create();
    }

    if (symbol_tables.symbol_table_map == NULL || symbol_tables.symbol_table_aout == NULL || symbol_tables.symbol_table_stabs == NULL)
    {
        fprintf(stderr, "Error: Failed to create symbol table\n");
        free_symbol_table();
        return -1;
    }

    // Try loading symbols from the file in different formats
    bool result = false;

    switch (symbol_type)
    {
    case SYMBOL_TYPE_MAP:
        result = symbols_load_map(symbol_tables.symbol_table_map, filename);
        break;

    case SYMBOL_TYPE_AOUT:
        result = symbols_load_aout(symbol_tables.symbol_table_aout, filename);
        break;

    case SYMBOL_TYPE_STABS:
        result = symbols_load_stabs(symbol_tables.symbol_table_stabs, filename);
        break;
    default:
        fprintf(stderr, "Error: Unsupported symbol type: %d\n", symbol_type);
        return -1;
    }

    if (result)
    {
        printf("Successfully loaded symbols from %s\n", filename);
        return 0;
    }

    return -1;
}

/**
 * @brief Handle the launch request from DAP
 *
 * This function initializes the debugger environment for the specified program:
 * 1. Sets up necessary debugger state with program and source information
 * 2. Initializes execution context and resets debugger state
 * 3. Loads symbol information if map file is provided
 * 4. Sends appropriate events to the client
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_launch_callback(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    printf("Launch command received\n");

    // Extract launch parameters from debugger state
    const char *program_path = server->debugger_state.program_path;
    const char *source_path = server->debugger_state.source_path;
    const char *map_path = server->debugger_state.map_path;
    bool stop_at_entry = server->debugger_state.stop_at_entry;
    bool no_debug = server->debugger_state.no_debug;

    // Log command line arguments if provided
    char **args = server->debugger_state.args;
    int args_count = server->debugger_state.args_count;

    if (!program_path)
    {
        printf("Error: Missing program path in debugger state\n");
        return -1;
    }

    printf("Launching program: %s\n", program_path ? program_path : "(null)");
    printf("Source path: %s\n", source_path ? source_path : "(not specified)");
    printf("Map file: %s\n", map_path ? map_path : "(not specified)");
    printf("Stop at entry: %s\n", stop_at_entry ? "yes" : "no");
    printf("No debug: %s\n", no_debug ? "yes" : "no");

    // Log command line arguments if present
    if (args && args_count > 0)
    {
        char arg_log[1024] = "Command line arguments:";
        size_t log_pos = strlen(arg_log);

        for (int i = 0; i < args_count && i < 10; i++)
        { // Limit to 10 args in log
            if (args[i])
            {
                int written = snprintf(arg_log + log_pos, sizeof(arg_log) - log_pos,
                                       " '%s'", args[i]);
                if (written > 0)
                {
                    log_pos += written;
                }
            }
        }

        if (args_count > 10)
        {
            snprintf(arg_log + log_pos, sizeof(arg_log) - log_pos, " ... (%d more)",
                     args_count - 10);
        }

        printf("%s\n", arg_log);
    }

    // Reset CPU state to appropriate values
    // In a real debugger, this would be where we would initialize the CPU
    // with the program's binary data

    // Set debugger state
    server->is_running = true;
    server->attached = true;
    server->debugger_state.has_stopped = true;
    server->debugger_state.current_thread_id = 1; // make sure we have a thread id

    server->debugger_state.source_line = 1;   // Start at line 1
    server->debugger_state.source_column = 1; // Start at column 1
    // Try to load symbols using different approaches
    bool symbols_loaded = false;

    // Load program
    if (program_path)
    {
        printf("Attempting to load program: %s\n", program_path);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                        "Loading program...\n");

        program_load(BOOT_AOUT, program_path, true);
        gPC = STARTADDR;
    }

    // Clear old symbols
    free_symbol_table();
    // Load symbols !!

    if (map_path)
    {
        printf("Attempting to load symbols from map file: %s\n", map_path);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                        "Loading symbols from map file...\n");

        if (init_symbol_support(map_path, SYMBOL_TYPE_MAP) == 0)
        {
            symbols_loaded = true;

            // Send a detailed message about the symbols
            char message[256];
            snprintf(message, sizeof(message), "Successfully loaded symbols from map file: %s\n", map_path);
            dap_server_send_output_category(server, DAP_OUTPUT_IMPORTANT, message);
        }
    }

    // If we have a.out file, try to update symbols from it
    if (program_path)
    {
        printf("Attempting to load symbols from program binary: %s\n", program_path);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                        "Loading symbols from program binary...\n");

        if (init_symbol_support(program_path, SYMBOL_TYPE_AOUT) == 0)
        {
            symbols_loaded = true;

            // Send a detailed message about the symbols
            char message[256];
            snprintf(message, sizeof(message), "Successfully loaded symbols from binary: %s\n", program_path);
            dap_server_send_output_category(server, DAP_OUTPUT_IMPORTANT, message);
        }
    }

    // Check for potential STABS file (look for .s file with same base name as program)
    if (!symbols_loaded && program_path)
    {
        char stabs_path[600] = {0};

        // Get base program name without extension
        const char *program_basename = strrchr(program_path, '/');
        if (program_basename)
        {
            program_basename++; // Skip the slash
        }
        else
        {
            program_basename = program_path;
        }

        // Find extension
        const char *extension = strrchr(program_basename, '.');
        if (extension)
        {
            // Take only the base name
            size_t base_len = extension - program_basename;
            char base_name[256] = {0};
            strncpy(base_name, program_basename, base_len < 255 ? base_len : 255);

            // Create potential STABS file path (same directory, .s extension)
            char dir_path[256] = {0};
            if (program_basename > program_path)
            {
                // Copy directory part
                size_t dir_len = program_basename - program_path - 1; // -1 to exclude the slash
                strncpy(dir_path, program_path, dir_len < 255 ? dir_len : 255);
            }

            // Construct full STABS path
            if (dir_path[0])
            {
                snprintf(stabs_path, sizeof(stabs_path), "%s/%s.s", dir_path, base_name);
            }
            else
            {
                snprintf(stabs_path, sizeof(stabs_path), "%s.s", base_name);
            }

            // Try to load STABS file
            printf("Attempting to load symbols from STABS file: %s\n", stabs_path);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                            "Looking for STABS debug file...\n");

            // Check if file exists before trying to load
            FILE *f = fopen(stabs_path, "r");
            if (f)
            {
                fclose(f);

                dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                                "Found STABS file, loading symbols...\n");

                if (init_symbol_support(stabs_path, SYMBOL_TYPE_STABS) == 0)
                {
                    symbols_loaded = true;

                    // Send a detailed message about the symbols
                    char message[1024];
                    snprintf(message, sizeof(message), "Successfully loaded symbols from STABS: %s\n", stabs_path);
                    dap_server_send_output_category(server, DAP_OUTPUT_IMPORTANT, message);
                }
            }
            else
            {
                dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                                "No STABS debug file found\n");
            }
        }
    }

    // If no symbols loaded from any source, warn the user
    if (!symbols_loaded)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                        "Warning: No symbols loaded. Source level debugging may not work correctly.\n");
    }
    // Update the server's program counter from the CPU
    server->debugger_state.program_counter = gPC;

    // Create initial stack trace
    debugger_build_stack_trace(gPC, 0);

    // If we have symbols, try to map initial PC to a source line
    int line = symbols_get_line(symbol_tables.symbol_table_map, gPC);
    const char *file = symbols_get_file(symbol_tables.symbol_table_map, gPC);

    if (line > 0 && file)
    {
        server->debugger_state.source_line = line;
        // Show initial source mapping
        char message[256];
        snprintf(message, sizeof(message), "Initial PC %06o mapped to %s:%d\n",
                    gPC, file, line);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, message);
    }


    // Send process event to indicate execution started
    dap_server_send_process_event(server, program_path, 1, true, "launch");

    // Output a confirmation message to the debug console
    char message[256];
    snprintf(message, sizeof(message), "Launched program: %s\n", program_path);
    dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, message);

    // Send stopped event if stopAtEntry is true
    if (stop_at_entry)
    {
        dap_server_send_stopped_event(server, "entry", "Stopped at program entry");
        printf("Stopped at entry point\n");
        set_cpu_run_mode(CPU_PAUSED);
        set_cpu_stop_reason(STOP_REASON_ENTRY);
    }
    else
    {
        // Send thread started event
        dap_server_send_thread_event(server, "started", 1);
        set_cpu_run_mode(CPU_RUNNING);
    }

    return 0; // Return success to ensure the response is properly set
}


static int cmd_configuration_done(DAPServer *server)
{
    printf("Configuration done command received\n");

    // Send the response
    server->debugger_state.configuration_done = true;

    return 0;
}

/// @brief Handle the restart request from DAP
/// @param server The DAP server instance
/// @return 0 if successful, -1 if error
/// @details This function handles the restart request from DAP.
/// It sends a response to the client with success=true.
static int cmd_restart(DAPServer *server)
{
    printf("Restart command received\n");

    // Respond to the client with success=true

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        return -1;
    }

    // Add success status
    cJSON_AddBoolToObject(body, "success", true);

    // Send the response
    dap_server_send_response(server, DAP_CMD_RESTART, server->sequence++,
                             server->current_command.request_seq, true, body);

    // Clean up
    cJSON_Delete(body);

    // Clear breakpoints
    breakpoint_manager_clear();

    // Reset CPU state
    cpu_reset();

    // Call launch callback to restart the program
    return cmd_launch_callback(server);

    return 0;
}

/// @brief Handle the disconnect request from DAP
/// @param server The DAP server instance
/// @return 0 if successful, -1 if error
/// @details This function handles the disconnect request from DAP.
/// It sends an exited event to the client, a terminated event to the client,
/// and a response to the client.
static int cmd_disconnect(DAPServer *server)
{
    printf("Disconnect command received\n");

    dap_server_send_exited_event(server, 0);

    // Send a terminated event to the client
    dap_server_send_terminated_event(server, false);

    // Send the response
    dap_server_send_response(server, DAP_CMD_DISCONNECT, server->sequence++,
                             server->current_command.request_seq, true, NULL);

    if (server->current_command.context.disconnect.terminate_debuggee)
    {
        // Kill your process/emulator/thread safely
        set_cpu_run_mode(CPU_SHUTDOWN);
    }
    else
    {
        set_cpu_run_mode(CPU_STOPPED);
    }

    return 0;
}

/// @brief Handle the terminate request from DAP

/// @param server The DAP server instance
/// @return 0 if successful, -1 if error
/// @details This function handles the terminate request from DAP.
/// It sends a response to the client with success=true.
/// Please stop the debuggee, but don't tear down the debug session completely yet.
static int cmd_terminate(DAPServer *server)
{
    printf("Terminate command received\n");

    // Send the response
    dap_server_send_response(server, DAP_CMD_TERMINATE, server->sequence++,
                             server->current_command.request_seq, true, NULL);

    // Send an exited event to the client
    dap_server_send_exited_event(server, 0);

    // Send a terminated event to the client
    dap_server_send_terminated_event(server, false);

    // DAP Adapter should now
    // 1. Stop/kill the emulator or target process
    // 2. Free any target-specific resources (RAM, CPU, threads, memory mappings, file handles...)
    // Here we do:
    // Set the CPU run mode to paused
    set_cpu_run_mode(CPU_PAUSED);
    return 0;
}

/// @brief DAP command to set a variable
/// @param server 
/// @return 
static int cmd_set_variable(DAPServer *server)
{
    return 0;
}


/// @brief DAP command to read memory
/// @param server 
/// @return 
static int cmd_read_memory(DAPServer *server)
{   
    // Extract parameters from the command context
    uint32_t memory_reference = server->current_command.context.read_memory.memory_reference;
    uint32_t offset = server->current_command.context.read_memory.offset;
    size_t byteCount = server->current_command.context.read_memory.count;

    uint32_t virtualAddress = memory_reference + offset;
    
    
    server->current_command.context.read_memory.base64_data = NULL;
    server->current_command.context.read_memory.unreadable_bytes = byteCount;

    if (byteCount ==0)
    {
        server->current_command.context.read_memory.base64_data = strdup("");
        server->current_command.context.read_memory.unreadable_bytes=0;
        return 0;
    }

    // read memory from memory_reference + offset, count bytes
    uint8_t *data = (uint8_t *)malloc(byteCount);
    if (!data)
    {    
        return 0;
    }

    memset(data, 0, byteCount);


    // Loop through the data and read each word, split the word in two so we add bytes to the data. Use ReadVirtualMemory to read the data.

    for (size_t i = 0; i < byteCount/2; i++)
    {
        int word = ReadVirtualMemory(virtualAddress, false);
        if (word == -1)
        {
            server->current_command.context.read_memory.unreadable_bytes = byteCount - i*2;
            break;
        }

        data[i*2] = (uint8_t)(word >> 8);
        data[i*2+1] = (uint8_t)(word & 0xFF);
        server->current_command.context.read_memory.unreadable_bytes -= 2;
        virtualAddress++;
    }

    // encode data to base64
    server->current_command.context.read_memory.base64_data = base64_encode(data, byteCount);

    // free data
    free(data);

    // return success
    return 0;

}

/// @brief DAP command to write memory
/// @param server 
/// @return 
static int cmd_write_memory(DAPServer *server)
{
    return 0;
}



// cpu/cpu_disasm.c
void  OpToStr(char *return_string, uint16_t max_len, uint16_t operand);

/// @brief DAP command to disassemble
/// @param server 
/// @return 
static int cmd_disassemble(DAPServer *server)
{
    uint16_t memory_reference = server->current_command.context.disassemble.memory_reference;
    int offset = server->current_command.context.disassemble.offset; // Offset in bytes
    int instruction_offset = server->current_command.context.disassemble.instruction_offset; // Offset in instructions (relative to the memory reference)
    int instruction_count = server->current_command.context.disassemble.instruction_count; // Number of instructions to disassemble
    bool resolve_symbols = server->current_command.context.disassemble.resolve_symbols; // Whether to resolve symbols

    int virtualAddress = memory_reference + offset + instruction_offset;

    // Allocate memory for the instructions
    server->current_command.context.disassemble.instructions = (DisassembleInstruction *)malloc(instruction_count * sizeof(DisassembleInstruction));
    if (!server->current_command.context.disassemble.instructions)
    {
        return -1;
    }

    // Clear the instructions
    memset(server->current_command.context.disassemble.instructions, 0, instruction_count * sizeof(DisassembleInstruction));

    // Set the actual instruction count to 0
    server->current_command.context.disassemble.actual_instruction_count = 0;


    // Loop through the instructions and disassemble each one
    for (int i = 0; i < instruction_count; i++)
    {
        // Get pointer to the instruction
        DisassembleInstruction *instruction = &server->current_command.context.disassemble.instructions[server->current_command.context.disassemble.actual_instruction_count];
        if (virtualAddress < 0)
        {
            // Might happen if the instruction offset is too large
            continue;
        }
        else
        {

            uint16_t operand = ReadVirtualMemory(virtualAddress, false);

            // Get the address of the instruction (DAP SPEC says it must be hex)
            char address_str[10];
            snprintf(address_str, sizeof(address_str), "0x%04x", virtualAddress);
            instruction->address = strdup(address_str);

    
            // Get the instruction
    
            // Disassemble the instruction
            char operand_str[50];
            OpToStr(operand_str, sizeof(operand_str), operand);

            char instruction_str[100];
            snprintf(instruction_str, sizeof(instruction_str), "%06o %s", operand, operand_str);

            instruction->instruction = strdup(instruction_str);
            instruction->symbol = NULL;
            // Get the symbol
            if (resolve_symbols)
            {
                const char *sym = get_symbol_for_address(virtualAddress);
                if (sym)
                {
                    instruction->symbol = strdup(sym);
                }
            }
        }

        // Add the instruction to the instructions array    
        server->current_command.context.disassemble.actual_instruction_count++;
        virtualAddress++;
    }


}




/// @brief Initialize the DAP server
/// @param port The port to listen on
/// @return 0 if successful, -1 if error
/// @details This function initializes the DAP server.
/// It creates a new DAP server instance and registers the necessary callbacks.
/// It then starts the server and returns the result.
int ndx_server_init(int port)
{
    // Initialize DAP server
    DAPServerConfig config = {
        .transport = {
            .type = DAP_TRANSPORT_TCP,
            .config = {
                .tcp = {
                    .host = "localhost",
                    .port = port}}},
    };

    server = dap_server_create(&config);
    if (!server)
    {
        return -1;
    }

    // Hook up callbacks

    // Register launch callback
    dap_server_register_command_callback(server, DAP_CMD_LAUNCH, cmd_launch_callback);

    // Register configuration done callback
    dap_server_register_command_callback(server, DAP_CMD_CONFIGURATION_DONE, cmd_configuration_done);

    // Register restart callback
    dap_server_register_command_callback(server, DAP_CMD_RESTART, cmd_restart);

    // Disconnect request
    dap_server_register_command_callback(server, DAP_CMD_DISCONNECT, cmd_disconnect);

    // Terminate request
    dap_server_register_command_callback(server, DAP_CMD_TERMINATE, cmd_terminate);

    // Hook up commands for stopping and starting the debugger's access to the CPU
    dap_server_register_command_callback(server, DAP_WAIT_FOR_DEBUGGER, cmd_wait_for_debugger);
    dap_server_register_command_callback(server, DAP_RELEASE_DEBUGGER, cmd_release_debugger);
    dap_server_register_command_callback(server, DAP_CHECK_CPU_EVENTS, cmd_check_cpu_events);

    // Set up stepping callbacks through command callbacks only
    // Register command-specific implementations using the wrapper functions
    dap_server_register_command_callback(server, DAP_CMD_NEXT, cmd_next);
    dap_server_register_command_callback(server, DAP_CMD_STEP_IN, cmd_step_in);
    dap_server_register_command_callback(server, DAP_CMD_STEP_OUT, cmd_step_out);

    // Register continue callback
    dap_server_register_command_callback(server, DAP_CMD_CONTINUE, cmd_continue);

    // Register exception breakpoint callback
    dap_server_register_command_callback(server, DAP_CMD_SET_EXCEPTION_BREAKPOINTS, on_set_exception_breakpoints);

    // Register breakpoint callback
    dap_server_register_command_callback(server, DAP_CMD_SET_BREAKPOINTS, cmd_set_breakpoints);

    // Register stack trace callback
    dap_server_register_command_callback(server, DAP_CMD_STACK_TRACE, cmd_stack_trace);

    // Register scopes callback
    dap_server_register_command_callback(server, DAP_CMD_SCOPES, cmd_scopes);

    // Register variables callback
    dap_server_register_command_callback(server, DAP_CMD_VARIABLES, cmd_variables);

    // Register set variable callback
    dap_server_register_command_callback(server, DAP_CMD_SET_VARIABLE, cmd_set_variable);

    // Register read memory callback
    dap_server_register_command_callback(server, DAP_CMD_READ_MEMORY, cmd_read_memory);

    // Register write memory callback
    dap_server_register_command_callback(server, DAP_CMD_WRITE_MEMORY, cmd_write_memory);

    // Register disassemble callback
    dap_server_register_command_callback(server, DAP_CMD_DISASSEMBLE, cmd_disassemble);



    // Configure which capabilities are supported
    set_default_dap_capabilities(server);

    // Start server and transport layer
    int result = dap_server_start(server);
    if (result != 0)
    {
        return result;
    }

    return 0;
}

int ndx_server_stop()
{
    if (!server)
    {
        return -1;
    }

    dap_server_stop(server);
    dap_server_free(server);
    server = NULL;
    return 0;
}

void debugger_kbd_input(char c)
{

    if (c=='q')
    {
        set_cpu_run_mode(CPU_SHUTDOWN);
    }

    // Print the current PC and run mode
    if (c == '.')
    {
        int runMode = get_cpu_run_mode();

        printf("P=%6o  RunMode=%d\n", gPC, runMode);
    }

    // Step the CPU
    if (c == ' ')
    {
        cpu_run(1);
        printf("%6o\n", gPC);
    }

    // Disassemble the instruction at the current PC
    if (c == 'd')
    {
        int runMode = get_cpu_run_mode();
        printf("P=%6o  RunMode=%d\n\n", gPC, runMode);

        int virtualAddress = gPC;
        for (int i = 0; i < 10; i++)
        {

            uint16_t operand = ReadVirtualMemory(virtualAddress, false);

            // Get the address of the instruction (DAP SPEC says it must be hex)
            printf("[%06o] ", virtualAddress);
            

    
            // Get the instruction
    
            // Disassemble the instruction
            char operand_str[50];
            OpToStr(operand_str, sizeof(operand_str), operand);

            char instruction_str[100];
            printf("%06o %s", operand, operand_str);

            const char *sym = get_symbol_for_address(virtualAddress);
            if (sym)
            {
                printf("    (%s)", sym);
            }
            
            printf("\n");

            virtualAddress++;
        }
            
    }
}

// Add this before the end of the #ifdef WITH_DEBUGGER section
#ifdef WITH_DEBUGGER
/**
 * @brief Find a symbol by address
 *
 * @param symtab Symbol table to search
 * @param address Memory address to look up
 * @return const char* Symbol name or NULL if not found
 */
const char *find_symbol_by_address(symbol_table_t *symtab, uint16_t address)
{
    if (!symtab)
    {
        return NULL;
    }

    const symbol_entry_t *entry = symbols_lookup_by_address(symtab, address);
    if (entry && entry->name)
    {
        return entry->name;
    }

    return NULL;
}

/**
 * @brief Helper function to find a symbol by address using the global symbol table
 *
 * @param address Memory address to look up
 * @return const char* Symbol name or NULL if not found
 */
const char *get_symbol_for_address(uint16_t address)
{
    return find_symbol_by_address(symbol_tables.symbol_table_aout, address);
}

/**
 * @brief Get source file and line for an address
 *
 * @param address Memory address to look up
 * @param line Pointer to store the line number
 * @return const char* Source filename or NULL if not found
 */
const char *get_source_location(uint16_t address, int *line)
{
    if (!symbol_tables.symbol_table_map || !line)
    {
        return NULL;
    }

    *line = symbols_get_line(symbol_tables.symbol_table_map, address);
    return symbols_get_file(symbol_tables.symbol_table_map, address);
}

/**
 * @brief Set up the default capabilities for the mock server
 *
 * This function configures which DAP capabilities our mock server
 * actually supports based on our implementation.
 *
 * @param server The DAP server instance
 * @return int The number of capabilities set
 */
int set_default_dap_capabilities(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    return dap_server_set_capabilities(server,
        DAP_CAP_CONFIG_DONE_REQUEST, true,
        DAP_CAP_EVALUATE_FOR_HOVERS, true,
        DAP_CAP_RESTART_REQUEST, true,
        DAP_CAP_TERMINATE_REQUEST, true,
        DAP_CAP_SET_VARIABLE, true,
        DAP_CAP_READ_MEMORY_REQUEST, true,
        DAP_CAP_WRITE_MEMORY_REQUEST, true,
        DAP_CAP_DISASSEMBLE_REQUEST, true,

        DAP_CAP_COUNT // End of list
    );
}
#endif // WITH_DEBUGGER

#endif // WITH_DEBUGGER

// Empty implementations when debugger is not enabled
#ifndef WITH_DEBUGGER

void start_debugger()
{
    // Do nothing when debugger is not enabled
}

int ndx_server_init(int port)
{
    (void)port;
    return -1; // Not implemented
}

int ndx_server_stop()
{
    return -1; // Not implemented
}

void debugger_kbd_input(char c)
{
    (void)c; // Unused parameter
}

#endif // !WITH_DEBUGGER
