#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>
#include <stdatomic.h>

#include "debugger.h"
#include "../cpu/cpu_types.h"
#include "../cpu/cpu_protos.h"

#define WITH_DEBUGGER

#ifdef WITH_DEBUGGER

#include "../../external/libdap/libdap/include/dap_server.h"
#include "../../external/libdap/libdap/include/dap_server_cmds.h"
#include "../../external/libdap/libdap/include/dap_protocol.h"
#include "../../external/libsymbols/include/symbols.h"
#include "symbols_support.h"
#include "machine_types.h"
#include "machine_protos.h"

#include "ndlib_types.h"
#include "ndlib_protos.h"

#include "debugger_protos.h"

// Forward declarations for CPU breakpoint functions

// Define scope IDs
#define SCOPE_ID_LOCALS 1000
#define SCOPE_ID_REGISTERS 1001
#define SCOPE_ID_INTERNAL_REGISTERS 1002

#define SCOPE_ID_STATUS_FLAGS 1100
#define SCOPE_ID_MEM_PT 1101
#define SCOPE_ID_MEM_APT 1102

// DAP server instance
DAPServer *server;

// Global symbol table
static symbol_table_t *g_symbol_table = NULL;

// Structure to hold the stack trace information
StackTrace stack_trace;

#ifdef _WIN32
#include <windows.h>
HANDLE p_debugger_thread;
#else
// Two defines for Linux, to make the compiler not complain about the WIN32 API (which is autogenerated in the proto file)

#include <stdatomic.h>
#include <pthread.h>
pthread_t p_debugger_thread;
#endif

#include "debugger_protos.h"
#include "debugger.h"

// Add atomic flag for thread termination
static atomic_bool debugger_thread_should_exit = false;

// Signal handler for the debugger thread
static void debugger_signal_handler(int sig) {
    if (sig == SIGINT) {
        atomic_store(&debugger_thread_should_exit, true);        
    }
}

#ifdef _WIN32
debugger_thread_win(LPVOID lpParam)
#else
void *debugger_thread(void *arg)
#endif
{
#ifdef _WIN32   
   // Hook up sigint handler to terminate the server
    signal(SIGINT, debugger_signal_handler);
#else
    // Set up signal handler for this thread
    struct sigaction sa;
    sa.sa_handler = debugger_signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGINT, &sa, NULL);
#endif

    int port = 4711;
    int ret = ndx_server_init(port);
    if (ret != 0)
    {
        printf("Failed to initialize DAP server\n");
        THREAD_RETURN(0);
    }

    printf("NDX debugger listening on port %d...\n", port);
    printf("Press Ctrl+C to exit\n");

    // Run the server's message processing loop with periodic checks for exit
    while (server->is_running)
    {
        if (debugger_thread_should_exit) break;
        
        if (dap_server_run(server) != 0)
        {
            fprintf(stderr, "Error: Server message loop failed.\n");
            break;
        }
        // Small sleep to prevent busy waiting
        usleep(10000); // 10ms
    }

    printf("Stopping DAP server\n");
    
    // Stop the server and transport
    dap_server_stop(server);

    // Clean up before exiting
    dap_server_free(server);
    server = NULL;    
    THREAD_RETURN(0);
}

void start_debugger()
{
    // Start the debugger thread
#ifdef _WIN32
    p_debugger_thread = CreateThread(
        NULL,                // default security attributes
        0,                   // default stack size
        debugger_thread_win, // thread function
        NULL,                // argument to thread function
        0,                   // default creation flags
        NULL);               // receive thread identifier (optional)
#else
    pthread_create(&p_debugger_thread, NULL, debugger_thread, NULL);
#endif
}

/// @brief Terminate the DAP server
/// @param exit_code
void ndx_server_terminate(int sig)
{

    // Sends a terminated event to the client and terminate the DAP server
    dap_server_terminate(server, 0);
}

/// @brief Stop the DAP server thread
void stop_debugger_thread()
{
    // Signal the thread to exit
    debugger_thread_should_exit = true;

    // Wait for the thread to finish
    if (p_debugger_thread) {
#ifdef _WIN32
        WaitForSingleObject(p_debugger_thread, INFINITE);
        CloseHandle(p_debugger_thread);
#else
        pthread_join(p_debugger_thread, NULL);
#endif
        p_debugger_thread = 0;
    }
}

const char *cpuStopReasonToString(CpuStopReason r)
{
    switch (r)
    {
    case STOP_REASON_STEP:
        return "step";
    case STOP_REASON_BREAKPOINT:
        return "breakpoint";
    case STOP_REASON_EXCEPTION:
        return "exception";
    case STOP_REASON_PAUSE:
        return "pause";
    case STOP_REASON_ENTRY:
        return "entry";
    case STOP_REASON_GOTO:
        return "goto";
    case STOP_REASON_FUNCTION_BREAKPOINT:
        return "function breakpoint";
    case STOP_REASON_DATA_BREAKPOINT:
        return "data breakpoint";
    case STOP_REASON_INSTRUCTION_BREAKPOINT:
        return "instruction breakpoint";
    default:
        return "pause";
    }
}

static int cmd_wait_for_debugger(DAPServer *server)
{
    printf("DAP adapter has requested CPU pause\n");

    // Tell CPU thread we want it to pause
    if (get_cpu_run_mode() == CPU_SHUTDOWN)
        return -1; // CPU is shutting down, no need to pause

    set_debugger_request_pause(true);

    // Now wait until CPU acknowledges and grants control
    while (!get_debugger_control_granted())
    {
        usleep(1000); // small sleep to avoid busy spin
    }

    // CPU is paused; debugger now owns control
    return 0;
}

static int cmd_release_debugger(DAPServer *server)
{
    printf("DAP adapter has requested CPU resume\n");

    // Release debugger's request to pause (let CPU decide to run/step)
    set_debugger_request_pause(false);

    // Notify CPU thread that debugger control is released
    set_debugger_control_granted(false);

    return 0;
}

static int cmd_check_cpu_events(DAPServer *server)
{

    CpuStopReason reason = get_cpu_stop_reason();
    if (reason != STOP_REASON_NONE)
    {
        const char *dap_reason_str = cpuStopReasonToString(reason);
        if (dap_server_send_stopped_event(server, dap_reason_str, NULL) == 0)
        {
            server->debugger_state.has_stopped = true;
            // Mesaage sent succesfully, now clear the stop reason
            set_cpu_stop_reason(STOP_REASON_NONE);
            dap_server_send_output_category(server, DAP_OUTPUT_STDOUT, dap_reason_str);
        }
    }

    return 0;
}

static void ensure_cpu_running()
{
    CPURunMode run_mode = get_cpu_run_mode();
    if ((run_mode == CPU_PAUSED) || (run_mode == CPU_BREAKPOINT))
    {
        // CPU is paused, so we need to resume it
        set_cpu_run_mode(CPU_RUNNING);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, "Switched CPU to running mode\n");
    }
}

/// @brief Find the memory address of the return address of the current stack frame.
/// @return The memory address of the return address of the current stack frame. -1 if no return address is found.
int32_t find_stack_return_address()
{
    // Check if we have any frames at all
    if (stack_trace.frame_count == 0)
    {
        // No frames, so we can't find a return address
        return -1;
    }

    // Get the previous frame's index
    int prev_frame = (stack_trace.current_frame - 1 + MAX_STACK_FRAMES) % MAX_STACK_FRAMES;

    // Get the return address of the previous frame
    return stack_trace.frames[prev_frame].return_address;
}

/// @brief Called by the CPU before executing an instruction
/// @details This function is called by the CPU before executing an instruction.
/// It builds the stack trace and sends it to the DAP server.
void debugger_build_stack_trace(uint16_t pc, uint16_t operand)
{

    // Check if this is a JPL instruction
    bool is_jpl =  ((operand & 0xF800) == 0134000);

    // Check if this is an EXIT instruction (146142)
    bool is_exit = (operand == 0146142);

    if (is_jpl)
    {
        // For JPL, we need to create a new stack frame
        // Calculate the return address (next instruction after JPL)
        uint16_t return_address = pc + 1;

        // Add the new frame to our circular buffer
        stack_trace.frames[stack_trace.current_frame].pc = pc;
        stack_trace.frames[stack_trace.current_frame].operand = operand;
        stack_trace.frames[stack_trace.current_frame].return_address = return_address;

        // Update frame tracking
        stack_trace.current_frame = (stack_trace.current_frame + 1) % MAX_STACK_FRAMES;
        if (stack_trace.frame_count < MAX_STACK_FRAMES)
        {
            stack_trace.frame_count++;
        }

        // Log the new frame for debugging
        char log_msg[256];
        snprintf(log_msg, sizeof(log_msg), "Added stack frame: PC=%06o, Operand=%06o, Return=%06o\n",
                 pc, operand, return_address);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_msg);
        return;
    }
    
    
    if (is_exit)
    {
        // For EXIT, we need to remove the last frame
        if (stack_trace.frame_count > 0)
        {
            // Move back one frame
            stack_trace.current_frame = (stack_trace.current_frame - 1 + MAX_STACK_FRAMES) % MAX_STACK_FRAMES;
            stack_trace.frame_count--;

            // Log the frame removal
            char log_msg[256];
            snprintf(log_msg, sizeof(log_msg), "Removed stack frame at PC=%06o\n", pc);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_msg);
        }
    }
    
}

/// @brief Step the CPU by the given step type
/// @param server The DAP server instance
/// @param step_type The type of step to take
/// @return 0 on success, -1 on failure
int step_cpu(DAPServer *server, StepType step_type)
{
    if (!server)
    {
        return -1;
    }

    uint16_t current_pc = gPC;
    uint16_t target_pc = 0;
    bool stepping_to_line = false;

    // Access the step command context
    StepCommandContext *ctx = &server->current_command.context.step;

    char log_message[256];

    // Step over - step to next line (F10)
    if (step_type == STEP_OVER)
    {

        // Implement special handling for EXIT instruction
        if (gReg->myreg_IR == 014614)
        {
            // Set a temporary breakpoint at the return address
            int return_address = find_stack_return_address();
            if (return_address <0) return -1;

            breakpoint_manager_add(return_address, BP_TYPE_TEMPORARY, NULL, NULL, NULL);
            ensure_cpu_running();
            return 0;
        }

        // Implement special handling for JMP, Conditional Jumps and SKP
        if (cpu_instruction_is_jump())
        {
            // Tell breakpoint manager to step one instruction
            breakpoint_manager_step_one();
            ensure_cpu_running();
            return 0;
        }

        // If we have symbol table and want to step by line
        if (g_symbol_table && ((ctx->granularity == DAP_STEP_GRANULARITY_LINE) || (ctx->granularity == DAP_STEP_GRANULARITY_STATEMENT)))
        {
            // Get the next line's address
            target_pc = symbols_get_next_line_address(g_symbol_table, current_pc);

            if (target_pc != 0 && target_pc != current_pc)
            {
                stepping_to_line = true;
                snprintf(log_message, sizeof(log_message),
                         "Stepping to next line at address %06o\n", target_pc);
                dap_server_send_output(server, log_message);
            }
        }

        // Set a temporary breakpoint at the target address if we're stepping to a line
        if (stepping_to_line && target_pc != 0 && target_pc != current_pc)
        {
            snprintf(log_message, sizeof(log_message), "Setting temporary breakpoint at address %06o\n", target_pc);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_message);

            // Use the CPU's breakpoint system to set a temporary breakpoint
            // This breakpoint will be automatically removed when hit
            breakpoint_manager_add(target_pc, BP_TYPE_TEMPORARY, NULL, NULL, NULL);
        }
        else
        {
            // Tell breakpoint manager to step one instruction
            breakpoint_manager_step_one();
        }

        ensure_cpu_running();
        return 0;
    }

    // Step in - step one instruction (F11)
    if (step_type == STEP_IN)
    {        
        snprintf(log_message, sizeof(log_message), "Stepping on instruction from %06o\n", current_pc);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_message);

        // Tell breakpoint manager to step one instruction
        breakpoint_manager_step_one();
        ensure_cpu_running();
        return 0;
    }

    // Step out - step to the next return address (Shift+F11)
    if (step_type == STEP_OUT)
    {
        // Step out - step to the next return address
        uint16_t return_address = find_stack_return_address();
        if (return_address != -1)
        {
            breakpoint_manager_add(return_address, BP_TYPE_TEMPORARY, NULL, NULL, NULL);
            ensure_cpu_running();
            return 0;
        }        
    }

    return -1;
}

/********************************** CALLBACKS **********************************/

/**
 * @brief Step Next command handler
 *
 * Handles the 'next' command by stepping over the current line/statement
 * VS Code F10
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_next(DAPServer *server)
{
    return step_cpu(server, STEP_OVER);
}

/**
 * @brief Step In command handler
 *
 * Handles the 'stepIn' command by stepping into a function call
 * VS Code F11
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_step_in(DAPServer *server)
{
    return step_cpu(server, STEP_IN);
}

/**
 * @brief Step Out command handler
 *
 * Handles the 'stepOut' command by stepping out of the current function
 * VS Code Shift+F11
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_step_out(DAPServer *server)
{
    return step_cpu(server, STEP_OUT);
}

static int cmd_continue(DAPServer *server)
{

    CPURunMode run_mode = get_cpu_run_mode();
    if ((run_mode == CPU_PAUSED) || (run_mode == CPU_BREAKPOINT))
    {
        set_cpu_run_mode(CPU_RUNNING);
        return 0;
    }

    return 1; // Error
}

/**
 * @brief Handle DAP scopes request
 *
 * This function creates scope objects for the variables visible in the current stack frame.
 * It defines several scopes:
 * 1. Locals - Local variables
 * 2. CPU Registers - CPU register values
 * 3. Memory - Memory regions
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_scopes(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    // Extract frame_id from the command context
    int frame_id = server->current_command.context.scopes.frame_id;

    printf("Scopes request for frame ID: %d\n", frame_id);

    // Define the number of scopes we'll provide
    const int NUM_SCOPES = 4; // Locals, Registers, Internal Registers, Memory

    // Allocate memory for the scopes
    DAPScope *scopes = (DAPScope *)calloc(NUM_SCOPES, sizeof(DAPScope));
    if (!scopes)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                        "Error: Failed to allocate memory for scopes\n");
        return -1;
    }

    // Set up Locals scope
    int scope_index = 0;
    scopes[scope_index].name = strdup("Locals");
    scopes[scope_index].variables_reference = SCOPE_ID_LOCALS;
    scopes[scope_index].named_variables = 5; // Number of local variables
    scopes[scope_index].indexed_variables = 0;
    scopes[scope_index].expensive = false;
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;

    // Set up CPU Registers scope
    scope_index++;
    scopes[scope_index].name = strdup("CPU Registers");
    scopes[scope_index].variables_reference = SCOPE_ID_REGISTERS;
    scopes[scope_index].named_variables = 8; // STS, D, P, B, L, A, T, X
    scopes[scope_index].indexed_variables = 0;
    scopes[scope_index].expensive = false;
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;

    // Set up Internal Registers scope
    scope_index++;
    scopes[scope_index].name = strdup("Internal Registers");
    scopes[scope_index].variables_reference = SCOPE_ID_INTERNAL_REGISTERS;
    scopes[scope_index].named_variables = 20; // 20 internal registers
    scopes[scope_index].indexed_variables = 0;
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;

    // Set up Memory scope
    scope_index++;
    scopes[scope_index].name = strdup("Memory");
    scopes[scope_index].variables_reference = SCOPE_ID_MEM_PT;
    scopes[scope_index].named_variables = 3; // Number of memory regions
    scopes[scope_index].indexed_variables = 0;
    scopes[scope_index].expensive = true; // Memory access is expensive
    // Source location fields are optional, set to 0/NULL
    scopes[scope_index].source_path = NULL;
    scopes[scope_index].line = 0;
    scopes[scope_index].column = 0;
    scopes[scope_index].end_line = 0;
    scopes[scope_index].end_column = 0;

    // Store the scopes in the command context for the DAP server to use
    server->current_command.context.scopes.scopes = scopes;
    server->current_command.context.scopes.scope_count = NUM_SCOPES;

    return 0;
}

/**
 * @brief Helper function to add a variable to the server's variable array
 *
 * @param server The DAP server instance
 * @param name Variable name
 * @param value Variable value
 * @param type Variable type
 * @param variables_reference Reference for child variables (0 for leaf variables)
 * @param memory_reference Optional memory reference
 * @param kind Variable kind (property, method, etc.)
 * @param attributes Array of attribute flags
 * @param num_attributes Number of attributes
 * @return DAPVariable* Pointer to the newly added variable or NULL on failure
 */
static DAPVariable *add_variable_to_array(
    DAPServer *server,
    const char *name,
    const char *value,
    const char *type,
    int variables_reference,
    uint32_t memory_reference,
    const char *kind,
    const char **attributes,
    int num_attributes)
{
    if (!server || !name || !value)
    {
        return NULL;
    }

    // Increase the count and reallocate the array
    server->current_command.context.variables.count++;
    server->current_command.context.variables.variable_array = realloc(
        server->current_command.context.variables.variable_array,
        server->current_command.context.variables.count * sizeof(DAPVariable));

    if (!server->current_command.context.variables.variable_array)
    {
        server->current_command.context.variables.count--;
        return NULL;
    }

    // Get a pointer to the newly added variable
    DAPVariable *var = &server->current_command.context.variables.variable_array[server->current_command.context.variables.count - 1];

    // Initialize the variable with the provided values
    if (name)
        var->name = strdup(name);
    else
        var->name = NULL;

    if (value)
        var->value = strdup(value);
    else
        var->value = NULL;

    if (type)
        var->type = strdup(type);
    else
        var->type = NULL;

    var->variables_reference = variables_reference;
    var->named_variables = 0;
    var->indexed_variables = 0;
    var->evaluate_name = NULL;

    // Set memory reference
    var->memory_reference = memory_reference;

    // Handle presentation hint (default initialization)
    var->presentation_hint.has_kind = false;
    var->presentation_hint.has_visibility = false;
    var->presentation_hint.attributes = DAP_VARIABLE_ATTR_NONE;

    // Set kind if provided
    if (kind && kind[0] != '\0')
    {
        var->presentation_hint.has_kind = true;

        // Map string kind to enum
        if (strcmp(kind, "property") == 0)
        {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_PROPERTY;
        }
        else if (strcmp(kind, "method") == 0)
        {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_METHOD;
        }
        else if (strcmp(kind, "class") == 0)
        {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_CLASS;
        }
        else if (strcmp(kind, "data") == 0)
        {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_DATA;
        }
        else if (strcmp(kind, "event") == 0)
        {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_EVENT;
        }
        else if (strcmp(kind, "baseClass") == 0)
        {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_BASE_CLASS;
        }
        else if (strcmp(kind, "innerClass") == 0)
        {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_INNER_CLASS;
        }
        else if (strcmp(kind, "interface") == 0)
        {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_INTERFACE;
        }
        else if (strcmp(kind, "mostDerived") == 0)
        {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_MOST_DERIVED;
        }
        else if (strcmp(kind, "virtual") == 0)
        {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_VIRTUAL;
        }
        else if (strcmp(kind, "dataBreakpoint") == 0)
        {
            var->presentation_hint.kind = DAP_VARIABLE_KIND_DATABREAKPOINT;
        }
        else
        {
            // Unknown kind
            var->presentation_hint.has_kind = false;
        }
    }

    // Set attributes if provided
    if (attributes && num_attributes > 0)
    {
        for (int i = 0; i < num_attributes; i++)
        {
            if (!attributes[i])
                continue;

            if (strcmp(attributes[i], "static") == 0)
            {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_STATIC;
            }
            else if (strcmp(attributes[i], "constant") == 0)
            {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_CONSTANT;
            }
            else if (strcmp(attributes[i], "readOnly") == 0)
            {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_READONLY;
            }
            else if (strcmp(attributes[i], "rawString") == 0)
            {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_RAWSTRING;
            }
            else if (strcmp(attributes[i], "hasObjectId") == 0)
            {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_HASOBJECTID;
            }
            else if (strcmp(attributes[i], "canHaveObjectId") == 0)
            {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_CANHAVEOBJECTID;
            }
            else if (strcmp(attributes[i], "hasSideEffects") == 0)
            {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_HASSIDEEFFECTS;
            }
            else if (strcmp(attributes[i], "hasDataBreakpoint") == 0)
            {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_HASDATABREAKPOINT;
            }
            else if (strcmp(attributes[i], "hasChildren") == 0)
            {
                var->presentation_hint.attributes |= DAP_VARIABLE_ATTR_HASCHILDREN;
            }
        }
    }

    return var;
}

/**
 * @brief Add local variables to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_local_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    snprintf(info_message, info_message_size,
             "Loading local variables for current context\n");

    // No local variables in this example, but in a real implementation
    // this would add variables from the current stack frame

    // Property kind for all variables
    const char *property_kind = "property";
    const char *no_attributes[] = {NULL};

    // Example dummy variable
    add_variable_to_array(
        server,
        "dummy",       // name
        "0",           // value
        "integer",     // type
        0,             // variablesReference
        0,             // memoryReference (no memory reference for locals)
        property_kind, // kind
        no_attributes, // attributes
        0              // num_attributes
    );
}

/**
 * @brief Add CPU register variables to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_register_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    snprintf(info_message, info_message_size,
             "Loading CPU registers\n");

    // Property kind with readonly attribute
    const char *property_kind = "property";
    const char *readonly_attrs[] = {"readOnly"};

    // Register formatting
    char value_str[32];

    // Add the ST register (Status register)
    snprintf(value_str, sizeof(value_str), "%06o", gSTSr);
    add_variable_to_array(
        server,
        "STS",                       // name
        value_str,                   // value
        "bitmap",                    // type
        SCOPE_ID_STATUS_FLAGS,       // variablesReference
        (uintptr_t)&gA & 0xFFFFFFFF, // memoryReference - safely truncate to 32-bit if needed
        property_kind,               // kind
        readonly_attrs,              // attributes
        1                            // num_attributes
    );

    // Add the D register (Data register)
    snprintf(value_str, sizeof(value_str), "%06o", gD);
    add_variable_to_array(
        server,
        "D",                         // name
        value_str,                   // value
        "integer",                   // type
        0,                           // variablesReference
        (uintptr_t)&gA & 0xFFFFFFFF, // memoryReference - safely truncate to 32-bit if needed
        property_kind,               // kind
        readonly_attrs,              // attributes
        1                            // num_attributes
    );

    // Add the P register (Program Counter)
    snprintf(value_str, sizeof(value_str), "%06o", gPC);
    add_variable_to_array(
        server,
        "P",                          // name
        value_str,                    // value
        "integer",                    // type
        0,                            // variablesReference
        (uintptr_t)&gPC & 0xFFFFFFFF, // memoryReference - safely truncate to 32-bit if needed
        property_kind,                // kind
        readonly_attrs,               // attributes
        1                             // num_attributes
    );

    // Add the B register (B register)
    snprintf(value_str, sizeof(value_str), "%06o", gB);
    add_variable_to_array(
        server,
        "B",                         // name
        value_str,                   // value
        "integer",                   // type
        0,                           // variablesReference
        (uintptr_t)&gB & 0xFFFFFFFF, // memoryReference - safely truncate to 32-bit if needed
        property_kind,               // kind
        readonly_attrs,              // attributes
        1                            // num_attributes
    );

    // Add the L register (Link register)
    snprintf(value_str, sizeof(value_str), "%06o", gL);
    add_variable_to_array(
        server,
        "L",                         // name
        value_str,                   // value
        "integer",                   // type
        0,                           // variablesReference
        (uintptr_t)&gL & 0xFFFFFFFF, // memoryReference - safely truncate to 32-bit if needed
        property_kind,               // kind
        readonly_attrs,              // attributes
        1                            // num_attributes
    );

    // Add the A register (Accumulator)
    snprintf(value_str, sizeof(value_str), "%06o", gA);
    add_variable_to_array(
        server,
        "A",                         // name
        value_str,                   // value
        "integer",                   // type
        0,                           // variablesReference
        (uintptr_t)&gA & 0xFFFFFFFF, // memoryReference - safely truncate to 32-bit if needed
        property_kind,               // kind
        readonly_attrs,              // attributes
        1                            // num_attributes
    );

    // Add the T register (T register)
    snprintf(value_str, sizeof(value_str), "%06o", gT);
    add_variable_to_array(
        server,
        "T",                         // name
        value_str,                   // value
        "integer",                   // type
        0,                           // variablesReference
        (uintptr_t)&gT & 0xFFFFFFFF, // memoryReference - safely truncate to 32-bit if needed
        property_kind,               // kind
        readonly_attrs,              // attributes
        1                            // num_attributes
    );

    // Add the X register (Index register)
    snprintf(value_str, sizeof(value_str), "%06o", gX);
    add_variable_to_array(
        server,
        "X",                         // name
        value_str,                   // value
        "integer",                   // type
        0,                           // variablesReference
        (uintptr_t)&gX & 0xFFFFFFFF, // memoryReference - safely truncate to 32-bit if needed
        property_kind,               // kind
        readonly_attrs,              // attributes
        1                            // num_attributes
    );
}

/**
 * @brief Add internal CPU register variables to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_internal_registers_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    snprintf(info_message, info_message_size,
             "Loading internal CPU registers\n");

    // Property kind with readonly attribute
    const char *property_kind = "property";
    const char *readonly_attrs[] = {"readOnly"};

    // Register formatting
    char value_str[32];

    // Define the internal registers with their addresses
    struct
    {
        const char *name;
        uint16_t *reg_ptr;
        const char *type;
    } internal_regs[] = {
        {"PANC", &gReg->reg_PANC, "octal"}, // Panel control
        {"PANS", &gReg->reg_PANS, "octal"}, // Panel status
        {"OPR", &gReg->reg_OPR, "octal"},   // Operator register
        {"LMP", &gReg->reg_LMP, "octal"},   // Panel data display buffer register
        {"PGS", &gReg->reg_PGS, "octal"},   // Paging status register
        {"PVL", &gReg->reg_PVL, "octal"},   // Page violation limit register
        {"IIC", &gReg->reg_IIC, "octal"},   // Internal interrupt code register
        {"IID", &gReg->reg_IID, "octal"},   // Internal interrupt detect register
        {"IIE", &gReg->reg_IIE, "octal"},   // Internal interrupt enable register
        {"PID", &gReg->reg_PID, "octal"},   // Priority interrupt detect register
        {"PIE", &gReg->reg_PIE, "octal"},   // Priority interrupt enable register
        {"CSR", &gReg->reg_CSR, "octal"},   // Control store register
        {"CCL", &gReg->reg_CCL, "octal"},   // Cache clear register
        {"LCIL", &gReg->reg_LCIL, "octal"}, // Lower cache inhibit limit register
        {"ALD", &gReg->reg_ALD, "octal"},   // Auto-load descriptor register
        {"UCIL", &gReg->reg_UCIL, "octal"}, // Upper cache inhibit limit register
        {"PES", &gReg->reg_PES, "octal"},   // Page error status register
        {"PGC", &gReg->reg_PGC, "octal"},   // Page count register
        {"PEA", &gReg->reg_PEA, "octal"},   // Page error address register
        {"ECCR", &gReg->reg_ECCR, "octal"}, // Error correction control register
    };

    const int num_regs = sizeof(internal_regs) / sizeof(internal_regs[0]);

    // Add each internal register to the variable array
    for (int i = 0; i < num_regs; i++)
    {
        // Format the register value in octal
        snprintf(value_str, sizeof(value_str), "%06o", *(internal_regs[i].reg_ptr));

        // Add the register to the variable array
        add_variable_to_array(
            server,
            internal_regs[i].name,                              // name
            value_str,                                          // value
            internal_regs[i].type,                              // type
            0,                                                  // variablesReference (no children)
            (uintptr_t)(internal_regs[i].reg_ptr) & 0xFFFFFFFF, // memoryReference - safely truncate to 32-bit if needed
            property_kind,                                      // kind
            readonly_attrs,                                     // attributes
            1                                                   // num_attributes
        );
    }
}

/**
 * @brief Add status flags from the STS register to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_status_flag_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    snprintf(info_message, info_message_size,
             "Loading CPU status flags\n");

    // Property kind with readonly attribute
    const char *property_kind = "property";
    const char *readonly_attrs[] = {"readOnly"};

    // Status flag definitions with bit positions
    struct
    {
        const char *name;
        int bit_pos;
        const char *description;
    } status_flags[] = {
        {"PTM", 0, "Program Test Mode"},
        {"TG", 1, "Trap Generate"},
        {"K", 2, "Stack Overflow Flag"},
        {"Z", 3, "Zero Flag"},
        {"Q", 4, "Q Flag"},
        {"O", 5, "Overflow Flag"},
        {"C", 6, "Carry Flag"},
        {"M", 7, "Memory Parity Error Flag"},
        {"PL", 8, "Program Level (bits 8-11)"},
        {"N100", 12, "Nord 100 Indicator"},
        {"SEXI", 13, "Extended MMS Addressing Indicator"},
        {"PONI", 14, "Memory Management On/Off Indicator"},
        {"IONI", 15, "Interrupt System On/Off Indicator"}};

    const int num_flags = sizeof(status_flags) / sizeof(status_flags[0]);

    // Get the current STS register value
    uint16_t sts_value = gSTSr;

    // Add each flag to the variable array
    for (int i = 0; i < num_flags; i++)
    {
        // Get the bit value (special handling for PL which is 4 bits)
        bool value;
        char value_str[32];

        if (strcmp(status_flags[i].name, "PL") == 0)
        {
            // Extract 4-bit PL field
            int pl_value = (sts_value >> 8) & 0x0F;
            snprintf(value_str, sizeof(value_str), "%d", pl_value);
        }
        else
        {
            // Extract 1-bit flags
            value = (sts_value >> status_flags[i].bit_pos) & 0x01;
            snprintf(value_str, sizeof(value_str), "%s", value ? "true" : "false");
        }

        // Create a display name with description
        char display_name[64];
        snprintf(display_name, sizeof(display_name), "%s (%s)",
                 status_flags[i].name, status_flags[i].description);

        // Add the flag to the variable array
        add_variable_to_array(
            server,
            display_name,                                                    // name with description
            value_str,                                                       // value (true/false or numeric for PL)
            strcmp(status_flags[i].name, "PL") == 0 ? "integer" : "boolean", // type
            0,                                                               // variablesReference (no children)
            0,                                                               // memoryReference
            property_kind,                                                   // kind
            readonly_attrs,                                                  // attributes
            1                                                                // num_attributes
        );
    }
}

/**
 * @brief Add memory regions to the variables array
 *
 * @param server The DAP server instance
 * @param info_message Buffer to write info message
 * @param info_message_size Size of info message buffer
 */
static void add_memory_region_variables(DAPServer *server, char *info_message, size_t info_message_size)
{
    snprintf(info_message, info_message_size,
             "Loading memory regions (Code section, Data section, etc.)\n");

    // Property kind with readonly attribute
    const char *property_kind = "property";
    const char *no_attributes[] = {NULL};

    // Add memory regions - these are examples and should be adjusted based on
    // the actual memory layout of the ND-100 system

    // Code section - an example region where program code resides
    add_variable_to_array(
        server,
        "Memory (Code - PT)", // name
        "000000-077777",      // value
        "memory",             // type
        1,                    // variablesReference
        SCOPE_ID_MEM_PT,      // memoryReference
        property_kind,        // kind
        no_attributes,        // attributes
        0                     // num_attributes
    );

    // Data section - an example region where data resides
    add_variable_to_array(
        server,
        "Memory (DATA - APT)", // name
        "000000-077777",       // value
        "memory",              // type
        SCOPE_ID_MEM_APT,      // variablesReference
        0000,                  // memoryReference
        property_kind,         // kind
        no_attributes,         // attributes
        0                      // num_attributes
    );
}

/**
 * @brief Handle DAP variables request
 *
 * This function provides variables for the requested container (scope).
 * It creates variables based on CPU state, memory content, etc.
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_variables(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    // Extract variables reference from the command context
    int variables_reference = server->current_command.context.variables.variables_reference;

    printf("Variables request for reference: %d\n", variables_reference);

    // Buffer for informational messages
    char info_message[256] = {0};

    // Reset variable array count
    server->current_command.context.variables.count = 0;
    server->current_command.context.variables.variable_array = NULL;

    // Handle different variable reference types
    switch (variables_reference)
    {
    case SCOPE_ID_LOCALS:
    {
        // Use our helper function for local variables
        add_local_variables(server, info_message, sizeof(info_message));
        break;
    }

    case SCOPE_ID_REGISTERS:
    {
        // Use our helper function for register variables
        add_register_variables(server, info_message, sizeof(info_message));
        break;
    }

    case SCOPE_ID_INTERNAL_REGISTERS:
    {
        // Use our helper function for internal registers variables
        add_internal_registers_variables(server, info_message, sizeof(info_message));
        break;
    }

    case SCOPE_ID_STATUS_FLAGS:
    {
        // Use our helper function for status flag variables
        add_status_flag_variables(server, info_message, sizeof(info_message));
        break;
    }

    case SCOPE_ID_MEM_PT:
    { // TODO: Make sure we read through PT
        // Use our helper function for memory region variables
        add_memory_region_variables(server, info_message, sizeof(info_message));
        break;
    }

    case SCOPE_ID_MEM_APT:
    { // TODO: Force PT to be APT
        // Use our helper function for memory region variables
        add_memory_region_variables(server, info_message, sizeof(info_message));
        break;
    }

    default:
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, "Unknown variable reference\n");
        break;
    }

    // Output info message if we have one
    if (info_message[0] != '\0')
    {
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, info_message);
    }

    // The variables will be used by handle_variables and converted to JSON
    // We don't need to clean up here, as the caller (handle_variables) will handle it
    // This is intentional to allow the response to be sent before freeing the memory

    return 0;
}



/// @brief Update a stack frame with the given memory reference
/// @param server DAP server instance
/// @param frame_index Index of the frame in the stack trace
/// @param frame_id Unique ID of the frame
/// @param memory_reference Memory reference of the frame
/// @return 0 on success, -1 on failure
void update_stack_frame (DAPServer *server, int frame_index, int frame_id, uint16_t memory_reference  ) {
     // Initialize the frame
    DAPStackFrame *frame = &server->current_command.context.stack_trace.frames[frame_index];
    frame->id = frame_id;
    frame->name = NULL;
    frame->source_path = NULL;
    frame->source_name = NULL;
    frame->line = 0;
    frame->column = 0;
    frame->end_line = 0;
    frame->end_column = 0;
    frame->can_restart = false;
    frame->instruction_pointer_reference = 0;
    frame->module_id = NULL;
    frame->presentation_hint = DAP_FRAME_PRESENTATION_NORMAL;

    // Try to get symbol information if we have a symbol table
    if (g_symbol_table)
    {
        // Get source location information
        int line = symbols_get_line(g_symbol_table, memory_reference);
        const char *file = symbols_get_file(g_symbol_table, memory_reference);
        const symbol_entry_t *symbol = symbols_lookup_by_address(g_symbol_table, memory_reference);

        if (line > 0 && file)
        {
            // We found source information
            frame->line = line;
            frame->source_path = strdup(file);

            // Extract source name from path
            const char *name = strrchr(file, '/');
            if (name)
            {
                frame->source_name = strdup(name + 1);
            }
            else
            {
                frame->source_name = strdup(file);
            }

            // Create a frame name from the symbol or PC
            char frame_name[256];
            if (symbol && symbol->name)
            {
                snprintf(frame_name, sizeof(frame_name), "%s at %06o", symbol->name, memory_reference);
            }
            else
            {
                snprintf(frame_name, sizeof(frame_name), "frame at %06o", memory_reference);
            }
            frame->name = strdup(frame_name);

            // Log the source mapping
            char log_msg[256];
            snprintf(log_msg, sizeof(log_msg), "PC %06o mapped to %s:%d\n",
                     memory_reference, file, line);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, log_msg);
        }
        else
        {
            // No source information found, use PC as frame name
            char frame_name[256];
            snprintf(frame_name, sizeof(frame_name), "frame at %06o", memory_reference);
            frame->name = strdup(frame_name);
        }
    }
    else
    {
        // No symbol table, just use PC as frame name
        char frame_name[256];
        snprintf(frame_name, sizeof(frame_name), "frame at %06o", memory_reference);
        frame->name = strdup(frame_name);   
    }

    // Set instruction pointer reference
    frame->instruction_pointer_reference = memory_reference;
}


/**
 * @brief Handle DAP stackTrace request
 *
 * This function creates a stack trace response with the current call stack,
 * including source file locations and line numbers. In this implementation,
 * we create at least one stack frame for the current PC location.
 *
 * @param server The DAP server instance
 * @return int 0 on success, -1 on failure
 */
static int cmd_stack_trace(DAPServer *server)
{

    if (!server)
    {
        return -1;
    }

    // Log stack trace request to debugger console
    char log_message[256];
    snprintf(log_message, sizeof(log_message),
             "StackTrace request for thread %d (start=%d, count=%d)",
             server->debugger_state.current_thread_id,
             server->current_command.context.stack_trace.start_frame,
             server->current_command.context.stack_trace.levels);
    dap_server_send_output(server, log_message);


    // If the number of tracked stack frames is 0 - we create ONE stack frame with the the symbol information for the current PC.
    if (stack_trace.frame_count == 0) {

        server->current_command.context.stack_trace.frame_count = 1;
        server->current_command.context.stack_trace.total_frames = 1;
        server->current_command.context.stack_trace.frames = malloc(sizeof(DAPStackFrame) *  server->current_command.context.stack_trace.frame_count);

        update_stack_frame(server, 0, 0,gPC);
        return 0;
    }   


    // Max number of frames to return.
    int stack_levels = server->current_command.context.stack_trace.levels;

    //	Index into the call stack (for pagination).
    int stack_start_frame = server->current_command.context.stack_trace.start_frame;


    // Number of all tacked frames
    int frame_count = stack_trace.frame_count+1;


    // Number of frames to return to the DAP client

    // Based on the number of stack levels and start frame, we need to calculate the number of frames to return.
    // We need to make sure we don't return more frames than we have.
    // We need to make sure we don't return frames that don't exist.
    // We need to make sure we return the frames in reverse order (most recent first).  
    
    // Calculate number of frames to return
    int frames_to_return = stack_levels;
    if (frames_to_return > (frame_count - stack_start_frame)) {
        frames_to_return = frame_count - stack_start_frame;
    }
    // Number of frames to skip
    int frames_to_skip = stack_start_frame;
    if (stack_start_frame > frame_count) {
        frames_to_skip = frame_count;
    }   


    // Allocate memory for the stack frames
    server->current_command.context.stack_trace.frame_count = frames_to_return;
    server->current_command.context.stack_trace.total_frames = frame_count;
    server->current_command.context.stack_trace.frames = malloc(sizeof(DAPStackFrame) * frames_to_return);

    // If we failed to allocate memory for the stack frames, return an error
    if (!server->current_command.context.stack_trace.frames)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                        "Error: Failed to allocate memory for stack frames\n");
        return -1;
    }


    // Fill in the current frame in stack trace 0
    update_stack_frame(server, 0, 0, gPC);

    // Fill in the stack frames in reverse order (most recent first)
    for (int i = 1; i < frames_to_return; i++) {
        int frame_idx = (stack_trace.current_frame - i + MAX_STACK_FRAMES) % MAX_STACK_FRAMES;
        DAPStackFrame* frame = &server->current_command.context.stack_trace.frames[frame_idx];

        uint16_t memory_reference = stack_trace.frames[frame_idx].return_address;
        update_stack_frame(server, i, frame_idx, memory_reference);
    }

    return 0;
}

/**
 * @brief Callback for setting exception breakpoints
 *
 * @param server The DAP server
 * @return int 0 on success, non-zero on failure
 */
static int on_set_exception_breakpoints(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    // Access filter data from the server's current command context
    const char **filters = server->current_command.context.exception.filters;
    size_t filter_count = server->current_command.context.exception.filter_count;
    const char **conditions = server->current_command.context.exception.conditions;
    size_t condition_count = server->current_command.context.exception.condition_count;

    // Log the received exception filters
    printf("Received %zu exception filters and %zu conditions\n", filter_count, condition_count);

    // TODO: Implement exception breakpoint handling
    return 0;
}

/**
 * @brief Command callback for setting breakpoints
 *
 * @param server DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_set_breakpoints(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    // Extract source file info from breakpoint context
    const char *source_path = server->current_command.context.breakpoint.source_path;
    int breakpoint_count = server->current_command.context.breakpoint.breakpoint_count;

    if (!source_path || breakpoint_count <= 0)
    {
        printf("Missing required breakpoint information\n");
        return -1;
    }

    // Get filename from path
    const char *source_name = strrchr(source_path, '/');
    if (source_name)
    {
        source_name++; // Skip the slash
    }
    else
    {
        source_name = source_path; // No slash found, use the whole path
    }

    printf("Setting %d breakpoints in %s\n", breakpoint_count, source_path);

    // Clear any existing breakpoints
    breakpoint_manager_clear();

    // Process each breakpoint
    for (int i = 0; i < breakpoint_count; i++)
    {
        DAPBreakpoint *bp = &server->current_command.context.breakpoint.breakpoints[i];

        bool validSymbol = false;
        // Try to get the memory address for this line number
        uint16_t address = 0;
        if (g_symbol_table)
        {
            // Get the address for this line in the source file
            validSymbol = symbols_find_address(g_symbol_table, source_path, &address, bp->line);
        }

        if (!validSymbol)
        {
            // If we couldn't map the line to an address, log it and continue

            char msg[256];
            snprintf(msg, sizeof(msg), "Warning: Could not map line %d to memory address - missing N_SO for %s\n", bp->line, source_path);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, msg);

            bp->verified = false;
            bp->message = strdup(msg);
            continue;
        }

        bp->verified = true;

        // Add the breakpoint to the manager
        breakpoint_manager_add(
            address,           // Memory address
            BP_TYPE_USER,      // Type of breakpoint
            bp->condition,     // Optional condition expression
            bp->hit_condition, // Optional hit condition
            bp->log_message    // Optional log message
        );

        // Log the breakpoint addition
        char msg[256];
        snprintf(msg, sizeof(msg), "Added breakpoint at address %06o (line %d)\n",
                 address, bp->line);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, msg);
    }

    // Send console output about the setup
    char output_msg[256];
    snprintf(output_msg, sizeof(output_msg), "Set %d breakpoints in %s\n",
             breakpoint_count, source_name);
    dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, output_msg);

    return 0;
}

/**
 * @brief Initialize symbol table support for the debugger
 *
 * This function loads symbols from a specified file, trying all supported formats:
 * 1. Map file format
 * 2. a.out binary format
 * 3. STABS .s file format
 *
 * @param filename Path to the symbol file
 * @return int 0 on success, non-zero on failure
 */
int init_symbol_support(const char *filename)
{
    if (!filename)
    {
        fprintf(stderr, "Error: No symbol file specified\n");
        return -1;
    }

    // Free previous symbol table if it exists
    if (g_symbol_table)
    {
        symbols_free(g_symbol_table);
        g_symbol_table = NULL;
    }

    // Initialize symbol table
    g_symbol_table = symbols_create();
    if (!g_symbol_table)
    {
        fprintf(stderr, "Error: Failed to create symbol table\n");
        return -1;
    }

    // Try loading symbols from the file in different formats
    bool result = false;

    // First try map file format
    printf("Attempting to load symbols from map file: %s\n", filename);
    result = symbols_load_map(g_symbol_table, filename);
    if (result)
    {
        printf("Successfully loaded symbols from map file: %s\n", filename);
        return 0;
    }

    // If that fails, try a.out format
    printf("Map file format failed, trying a.out format: %s\n", filename);
    result = symbols_load_aout(g_symbol_table, filename);
    if (result)
    {
        printf("Successfully loaded symbols from a.out binary: %s\n", filename);
        return 0;
    }

    // If that fails too, try STABS format
    printf("a.out format failed, trying STABS format: %s\n", filename);
    result = symbols_load_stabs(g_symbol_table, filename);
    if (result)
    {
        printf("Successfully loaded symbols from STABS file: %s\n", filename);
        return 0;
    }

    // If all loading attempts failed
    fprintf(stderr, "Error: Failed to load symbols from %s in any supported format\n", filename);
    symbols_free(g_symbol_table);
    g_symbol_table = NULL;
    return -1;
}

/**
 * @brief Register symbol information with the DAP server
 *
 * @param server The DAP server instance
 * @param symbol_file Path to the symbol file
 * @return int 0 on success, non-zero on failure
 */
int register_symbol_file_with_dap(DAPServer *server, const char *symbol_file)
{
    if (!server || !symbol_file)
    {
        return -1;
    }

    // Load symbols
    int result = init_symbol_support(symbol_file);
    if (result != 0)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                        "Failed to load symbols from any supported format\n");
        return result;
    }

    // Get symbol statistics
    int symbol_count = 0;
    int line_count = 0;

    // Send a console output event to notify the client
    char message[256];
    snprintf(message, sizeof(message), "Loaded symbol information from %s\n", symbol_file);
    dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, message);

    // Print more detailed info about symbols
    // In a real implementation, you would count symbols and line entries
    snprintf(message, sizeof(message), "Symbol table contains address-to-line mapping information\n");
    dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, message);

    return 0;
}

/**
 * @brief Handle the launch request from DAP
 *
 * This function initializes the debugger environment for the specified program:
 * 1. Sets up necessary debugger state with program and source information
 * 2. Initializes execution context and resets debugger state
 * 3. Loads symbol information if map file is provided
 * 4. Sends appropriate events to the client
 *
 * @param server The DAP server instance
 * @return int 0 on success, non-zero on failure
 */
static int cmd_launch_callback(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    printf("Launch command received\n");

    // Extract launch parameters from debugger state
    const char *program_path = server->debugger_state.program_path;
    const char *source_path = server->debugger_state.source_path;
    const char *map_path = server->debugger_state.map_path;
    bool stop_at_entry = server->debugger_state.stop_at_entry;
    bool no_debug = server->debugger_state.no_debug;

    // Log command line arguments if provided
    char **args = server->debugger_state.args;
    int args_count = server->debugger_state.args_count;

    if (!program_path)
    {
        printf("Error: Missing program path in debugger state\n");
        return -1;
    }

    printf("Launching program: %s\n", program_path ? program_path : "(null)");
    printf("Source path: %s\n", source_path ? source_path : "(not specified)");
    printf("Map file: %s\n", map_path ? map_path : "(not specified)");
    printf("Stop at entry: %s\n", stop_at_entry ? "yes" : "no");
    printf("No debug: %s\n", no_debug ? "yes" : "no");

    // Log command line arguments if present
    if (args && args_count > 0)
    {
        char arg_log[1024] = "Command line arguments:";
        size_t log_pos = strlen(arg_log);

        for (int i = 0; i < args_count && i < 10; i++)
        { // Limit to 10 args in log
            if (args[i])
            {
                int written = snprintf(arg_log + log_pos, sizeof(arg_log) - log_pos,
                                       " '%s'", args[i]);
                if (written > 0)
                {
                    log_pos += written;
                }
            }
        }

        if (args_count > 10)
        {
            snprintf(arg_log + log_pos, sizeof(arg_log) - log_pos, " ... (%d more)",
                     args_count - 10);
        }

        printf("%s\n", arg_log);
    }

    // Reset CPU state to appropriate values
    // In a real debugger, this would be where we would initialize the CPU
    // with the program's binary data

    // Set debugger state
    server->is_running = true;
    server->attached = true;
    server->debugger_state.has_stopped = true;
    server->debugger_state.current_thread_id = 1; // make sure we have a thread id

    server->debugger_state.source_line = 1;   // Start at line 1
    server->debugger_state.source_column = 1; // Start at column 1
    // Try to load symbols using different approaches
    bool symbols_loaded = false;

    // Load program
    if (program_path)
    {
        printf("Attempting to load program: %s\n", program_path);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                        "Loading program...\n");

        program_load(BOOT_AOUT, program_path, true);
        gPC = STARTADDR;
    }

    // If map file is provided, try it first
    if (map_path)
    {
        printf("Attempting to load symbols from map file: %s\n", map_path);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                        "Loading symbols from map file...\n");

        if (register_symbol_file_with_dap(server, map_path) == 0)
        {
            symbols_loaded = true;

            // Send a detailed message about the symbols
            char message[256];
            snprintf(message, sizeof(message), "Successfully loaded symbols from map file: %s\n", map_path);
            dap_server_send_output_category(server, DAP_OUTPUT_IMPORTANT, message);
        }
    }

    // If no symbols yet and we have a program path, try it as a.out
    if (!symbols_loaded && program_path)
    {
        printf("Attempting to load symbols from program binary: %s\n", program_path);
        dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                        "Loading symbols from program binary...\n");

        if (register_symbol_file_with_dap(server, program_path) == 0)
        {
            symbols_loaded = true;

            // Send a detailed message about the symbols
            char message[256];
            snprintf(message, sizeof(message), "Successfully loaded symbols from binary: %s\n", program_path);
            dap_server_send_output_category(server, DAP_OUTPUT_IMPORTANT, message);
        }
    }

    // Check for potential STABS file (look for .s file with same base name as program)
    if (!symbols_loaded && program_path)
    {
        char stabs_path[600] = {0};

        // Get base program name without extension
        const char *program_basename = strrchr(program_path, '/');
        if (program_basename)
        {
            program_basename++; // Skip the slash
        }
        else
        {
            program_basename = program_path;
        }

        // Find extension
        const char *extension = strrchr(program_basename, '.');
        if (extension)
        {
            // Take only the base name
            size_t base_len = extension - program_basename;
            char base_name[256] = {0};
            strncpy(base_name, program_basename, base_len < 255 ? base_len : 255);

            // Create potential STABS file path (same directory, .s extension)
            char dir_path[256] = {0};
            if (program_basename > program_path)
            {
                // Copy directory part
                size_t dir_len = program_basename - program_path - 1; // -1 to exclude the slash
                strncpy(dir_path, program_path, dir_len < 255 ? dir_len : 255);
            }

            // Construct full STABS path
            if (dir_path[0])
            {
                snprintf(stabs_path, sizeof(stabs_path), "%s/%s.s", dir_path, base_name);
            }
            else
            {
                snprintf(stabs_path, sizeof(stabs_path), "%s.s", base_name);
            }

            // Try to load STABS file
            printf("Attempting to load symbols from STABS file: %s\n", stabs_path);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                            "Looking for STABS debug file...\n");

            // Check if file exists before trying to load
            FILE *f = fopen(stabs_path, "r");
            if (f)
            {
                fclose(f);

                dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                                "Found STABS file, loading symbols...\n");

                if (register_symbol_file_with_dap(server, stabs_path) == 0)
                {
                    symbols_loaded = true;

                    // Send a detailed message about the symbols
                    char message[1024];
                    snprintf(message, sizeof(message), "Successfully loaded symbols from STABS: %s\n", stabs_path);
                    dap_server_send_output_category(server, DAP_OUTPUT_IMPORTANT, message);
                }
            }
            else
            {
                dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE,
                                                "No STABS debug file found\n");
            }
        }
    }

    // If no symbols loaded from any source, warn the user
    if (!symbols_loaded)
    {
        dap_server_send_output_category(server, DAP_OUTPUT_STDERR,
                                        "Warning: No symbols loaded. Source level debugging may not work correctly.\n");
    }
    // Update the server's program counter from the CPU
    server->debugger_state.program_counter = gPC;

    // If we have symbols, try to map initial PC to a source line
    if (g_symbol_table)
    {
        int line = symbols_get_line(g_symbol_table, gPC);
        const char *file = symbols_get_file(g_symbol_table, gPC);

        if (line > 0 && file)
        {
            server->debugger_state.source_line = line;
            // Show initial source mapping
            char message[256];
            snprintf(message, sizeof(message), "Initial PC %06o mapped to %s:%d\n",
                     gPC, file, line);
            dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, message);
        }
    }

    // Send process event to indicate execution started
    dap_server_send_process_event(server, program_path, 1, true, "launch");

    // Output a confirmation message to the debug console
    char message[256];
    snprintf(message, sizeof(message), "Launched program: %s\n", program_path);
    dap_server_send_output_category(server, DAP_OUTPUT_CONSOLE, message);

    // Send stopped event if stopAtEntry is true
    if (stop_at_entry)
    {
        dap_server_send_stopped_event(server, "entry", "Stopped at program entry");
        printf("Stopped at entry point\n");
        set_cpu_run_mode(CPU_PAUSED);
        set_cpu_stop_reason(STOP_REASON_ENTRY);
    }
    else
    {
        // Send thread started event
        dap_server_send_thread_event(server, "started", 1);
        set_cpu_run_mode(CPU_RUNNING);
    }

    return 0; // Return success to ensure the response is properly set
}

/// @brief Handle the restart request from DAP
/// @param server The DAP server instance
/// @return 0 if successful, -1 if error
/// @details This function handles the restart request from DAP.
/// It sends a response to the client with success=true.
static int cmd_restart(DAPServer *server)
{
    printf("Restart command received\n");

    // Respond to the client with success=true

    // Create response body
    cJSON *body = cJSON_CreateObject();
    if (!body)
    {
        return -1;
    }

    // Add success status
    cJSON_AddBoolToObject(body, "success", true);

    // Send the response
    dap_server_send_response(server, DAP_CMD_RESTART, server->sequence++,
                             server->current_command.request_seq, true, body);

    // Clean up
    cJSON_Delete(body);

    // Clear breakpoints
    breakpoint_manager_clear();

    // Reset CPU state
    cpu_reset();

    // Call launch callback to restart the program
    return cmd_launch_callback(server);

    return 0;
}

/// @brief Handle the disconnect request from DAP
/// @param server The DAP server instance
/// @return 0 if successful, -1 if error
/// @details This function handles the disconnect request from DAP.
/// It sends an exited event to the client, a terminated event to the client,
/// and a response to the client.
static int cmd_disconnect(DAPServer *server)
{
    printf("Disconnect command received\n");

    dap_server_send_exited_event(server, 0);

    // Send a terminated event to the client
    dap_server_send_terminated_event(server, false);

    // Send the response
    dap_server_send_response(server, DAP_CMD_DISCONNECT, server->sequence++,
                             server->current_command.request_seq, true, NULL);

    if (server->current_command.context.disconnect.terminate_debuggee)
    {
        // Kill your process/emulator/thread safely
        set_cpu_run_mode(CPU_SHUTDOWN);
    }

    return 0;
}

/// @brief Handle the terminate request from DAP

/// @param server The DAP server instance
/// @return 0 if successful, -1 if error
/// @details This function handles the terminate request from DAP.
/// It sends a response to the client with success=true.
/// Please stop the debuggee, but don't tear down the debug session completely yet.
static int cmd_terminate(DAPServer *server)
{
    printf("Terminate command received\n");

    // Send the response
    dap_server_send_response(server, DAP_CMD_TERMINATE, server->sequence++,
                             server->current_command.request_seq, true, NULL);

    // Send an exited event to the client
    dap_server_send_exited_event(server, 0);

    // Send a terminated event to the client
    dap_server_send_terminated_event(server, false);

    // DAP Adapter should now
    // 1. Stop/kill the emulator or target process
    // 2. Free any target-specific resources (RAM, CPU, threads, memory mappings, file handles...)
    // Here we do:
    // Set the CPU run mode to paused
    set_cpu_run_mode(CPU_PAUSED);
    return 0;
}

/// @brief Initialize the DAP server
/// @param port The port to listen on
/// @return 0 if successful, -1 if error
/// @details This function initializes the DAP server.
/// It creates a new DAP server instance and registers the necessary callbacks.
/// It then starts the server and returns the result.
int ndx_server_init(int port)
{
    // Initialize DAP server
    DAPServerConfig config = {
        .transport = {
            .type = DAP_TRANSPORT_TCP,
            .config = {
                .tcp = {
                    .host = "localhost",
                    .port = port}}},
    };

    server = dap_server_create(&config);
    if (!server)
    {
        return -1;
    }

    // Hook up callbacks

    // Register launch callback
    dap_server_register_command_callback(server, DAP_CMD_LAUNCH, cmd_launch_callback);

    // Register restart callback
    dap_server_register_command_callback(server, DAP_CMD_RESTART, cmd_restart);

    // Disconnect request
    dap_server_register_command_callback(server, DAP_CMD_DISCONNECT, cmd_disconnect);

    // Terminate request
    dap_server_register_command_callback(server, DAP_CMD_TERMINATE, cmd_terminate);

    // Hook up commands for stopping and starting the debugger's access to the CPU
    dap_server_register_command_callback(server, DAP_WAIT_FOR_DEBUGGER, cmd_wait_for_debugger);
    dap_server_register_command_callback(server, DAP_RELEASE_DEBUGGER, cmd_release_debugger);
    dap_server_register_command_callback(server, DAP_CHECK_CPU_EVENTS, cmd_check_cpu_events);

    // Set up stepping callbacks through command callbacks only
    // Register command-specific implementations using the wrapper functions
    dap_server_register_command_callback(server, DAP_CMD_NEXT, cmd_next);
    dap_server_register_command_callback(server, DAP_CMD_STEP_IN, cmd_step_in);
    dap_server_register_command_callback(server, DAP_CMD_STEP_OUT, cmd_step_out);

    // Register continue callback
    dap_server_register_command_callback(server, DAP_CMD_CONTINUE, cmd_continue);

    // Register exception breakpoint callback
    dap_server_register_command_callback(server, DAP_CMD_SET_EXCEPTION_BREAKPOINTS, on_set_exception_breakpoints);

    // Register breakpoint callback
    dap_server_register_command_callback(server, DAP_CMD_SET_BREAKPOINTS, cmd_set_breakpoints);

    // Register stack trace callback
    dap_server_register_command_callback(server, DAP_CMD_STACK_TRACE, cmd_stack_trace);

    // Register scopes callback
    dap_server_register_command_callback(server, DAP_CMD_SCOPES, cmd_scopes);

    // Register variables callback
    dap_server_register_command_callback(server, DAP_CMD_VARIABLES, cmd_variables);

    // Configure which capabilities are supported
    set_default_dap_capabilities(server);

    // Start server and transport layer
    int result = dap_server_start(server);
    if (result != 0) {
        return result;
    } 

    return 0;
}

int ndx_server_stop()
{
    if (!server)
    {
        return -1;
    }

    dap_server_stop(server);
    dap_server_free(server);
    server = NULL;
    return 0;
}

void debugger_kbd_input(char c)
{
    if (c == '.')
    {
        int runMode = get_cpu_run_mode();

        printf("P=%6o  RunMode=%d\n", gPC, runMode);
    }

    if (c == ' ')
    {
        cpu_run(1);
        printf("%6o\n", gPC);
    }
}

// Add this before the end of the #ifdef WITH_DEBUGGER section
#ifdef WITH_DEBUGGER
/**
 * @brief Find a symbol by address
 *
 * @param symtab Symbol table to search
 * @param address Memory address to look up
 * @return const char* Symbol name or NULL if not found
 */
const char *find_symbol_by_address(symbol_table_t *symtab, uint16_t address)
{
    if (!symtab)
    {
        return NULL;
    }

    const symbol_entry_t *entry = symbols_lookup_by_address(symtab, address);
    if (entry && entry->name)
    {
        return entry->name;
    }

    return NULL;
}

/**
 * @brief Helper function to find a symbol by address using the global symbol table
 *
 * @param address Memory address to look up
 * @return const char* Symbol name or NULL if not found
 */
const char *get_symbol_for_address(uint16_t address)
{
    return find_symbol_by_address(g_symbol_table, address);
}

/**
 * @brief Get source file and line for an address
 *
 * @param address Memory address to look up
 * @param line Pointer to store the line number
 * @return const char* Source filename or NULL if not found
 */
const char *get_source_location(uint16_t address, int *line)
{
    if (!g_symbol_table || !line)
    {
        return NULL;
    }

    *line = symbols_get_line(g_symbol_table, address);
    return symbols_get_file(g_symbol_table, address);
}

/**
 * @brief Set up the default capabilities for the mock server
 *
 * This function configures which DAP capabilities our mock server
 * actually supports based on our implementation.
 *
 * @param server The DAP server instance
 * @return int The number of capabilities set
 */
int set_default_dap_capabilities(DAPServer *server)
{
    if (!server)
    {
        return -1;
    }

    return dap_server_set_capabilities(server,
                                       // These capabilities are fully implemented in the mock server
                                       DAP_CAP_CONFIG_DONE_REQUEST, true,
                                       DAP_CAP_EVALUATE_FOR_HOVERS, true,
                                       DAP_CAP_RESTART_REQUEST, true,
                                       DAP_CAP_TERMINATE_REQUEST, true,

                                       // End of capabilities
                                       DAP_CAP_COUNT);
}
#endif // WITH_DEBUGGER

#endif // WITH_DEBUGGER

// Empty implementations when debugger is not enabled
#ifndef WITH_DEBUGGER

void start_debugger()
{
    // Do nothing when debugger is not enabled
}

int ndx_server_init(int port)
{
    (void)port;
    return -1; // Not implemented
}

int ndx_server_stop()
{
    return -1; // Not implemented
}

void debugger_kbd_input(char c)
{
    (void)c; // Unused parameter
}

#endif // !WITH_DEBUGGER
